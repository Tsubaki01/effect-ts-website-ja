---
title: Effect vs fp-ts
excerpt: Effectとfp-tsライブラリの主要な機能の詳細な比較。型付きサービス、ビルトインサービス、エラーハンドリング、パイプ可能なAPI、デュアルAPI、テスト可能性、リソース管理、中断、欠陥、ファイバーベースの並行処理、リトライポリシー、ロギング、スケジューリング、キャッシング、バッチ処理、メトリクス、トレーシング、設定、イミュータブルデータ構造、ストリーム処理を含む。
bottomNavigation: pagination
---

## FAQ

### Effectとfp-tsのバンドルサイズの比較

**Q: Effectとfp-tsを使用した2つのシンプルなプログラムのバンドルサイズを比較しました。なぜEffectのバンドルサイズが大きいのですか？**

A: Effectとfp-tsは異なる目的のために設計されたシステムであるため、バンドルサイズが異なるのは自然なことです。
Effectのバンドルサイズが大きいのは、ファイバランタイムが含まれているためであり、これはその機能にとって重要です。
初期のバンドルサイズは大きく見えるかもしれませんが、Effectを使用するにつれてオーバーヘッドは減少します。

**Q: Effectとfp-tsの間のバンドルサイズの違いを選択する際に気にするべきですか？**

A: 必ずしもそうではありません。プロジェクトの特定の要件と各ライブラリの利点を考慮してください。

## 比較表

以下の表は、Effectと[fp-ts](https://github.com/gcanti/fp-ts)ライブラリの機能を比較したものです。

| 機能                      | fp-ts | Effect |
| ------------------------- | ----- | ------ |
| Typed Services            | ❌    | ✅     |
| Built-in Services         | ❌    | ✅     |
| Typed errors              | ✅    | ✅     |
| Pipeable APIs             | ✅    | ✅     |
| Dual APIs                 | ❌    | ✅     |
| Testability               | ❌    | ✅     |
| Resource Management       | ❌    | ✅     |
| Interruptions             | ❌    | ✅     |
| Defects                   | ❌    | ✅     |
| Fiber-Based Concurrency   | ❌    | ✅     |
| Fiber Supervision         | ❌    | ✅     |
| Retry and Retry Policies  | ❌    | ✅     |
| Built-in Logging          | ❌    | ✅     |
| Built-in Scheduling       | ❌    | ✅     |
| Built-in Caching          | ❌    | ✅     |
| Built-in Batching         | ❌    | ✅     |
| Metrics                   | ❌    | ✅     |
| Tracing                   | ❌    | ✅     |
| Configuration             | ❌    | ✅     |
| Immutable Data Structures | ❌    | ✅     |
| Stream Processing         | ❌    | ✅     |

各機能の説明は以下の通りです：

### Typed Services

fp-tsとEffectの両方のライブラリは、型レベルで要件を追跡する機能を提供し、特定の型を持つサービスを定義して使用することができます。fp-tsでは`Reader<R, E, A>`型を利用でき、Effectでは`Effect<A, E, R>`型が利用可能です。fp-tsでは`R`型パラメータが反変であるため、競合を避ける保証がなく、依存関係管理のための基本的なツールしか提供されていないことに注意が必要です。

一方、Effectでは`R`型パラメータが共変であり、複数のエフェクトが関与する場合に型レベルで依存関係をマージする能力を持つAPIがすべて提供されています。Effectはまた、依存関係の管理を簡素化するために特別に設計された`Tag`、`Context`、`Layer`などのツールを提供しています。これらのツールは、コード内での依存関係の取り扱いを容易かつ柔軟にし、複雑なアプリケーションの構成と管理を容易にします。

### Built-in Services

Effectライブラリには`Clock`、`Random`、`Tracer`などのビルトインサービスが含まれていますが、fp-tsにはデフォルトのサービスは提供されていません。

### Typed errors

両方のライブラリは型付きエラーをサポートしており、特定の型を持つエラーを定義して処理することができます。しかし、Effectでは、複数のエフェクトが関与する場合にすべてのAPIが型レベルでエラーをマージする能力を持ち、各エフェクトは異なる種類のエラーで失敗する可能性があります。

これは、失敗する可能性のある複数のエフェクトを組み合わせると、結果として得られるエラーの型が個々のエラー型の合併になることを意味します。Effectは、これらのマージされたエラー型を効果的に処理および管理するためのユーティリティと型レベルの操作を提供します。

### Pipeable APIs

fp-tsとEffectの両方のライブラリは、`pipe`関数を使用して操作を機能的かつ読みやすい方法で構成およびシーケンスするためのパイプ可能なAPIを提供しています。しかし、Effectはさらに一歩進んで、各データ型に`.pipe()`メソッドを提供しており、毎回`pipe`関数を明示的にインポートする必要がなく、パイプラインをより便利に扱うことができます。

### Dual APIs

Effectライブラリは、同じAPIを異なる方法（例えば、「data-last」と「data-first」のバリアント）で使用できるデュアルAPIを提供しています。

### Testability

fp-tsの機能的なスタイルは、一般的にそれを使用して書かれたコードのテスト可能性を促進しますが、ライブラリ自体にはテストフェーズ専用のツールは提供されていません。一方、Effectはテストプロセスを簡素化するために特別に設計された追加のツールを提供することで、テスト可能性をさらに一歩進めています。

Effectは、テスト可能性を向上させるためのさまざまなユーティリティを提供しています。例えば、`TestClock`ユーティリティを提供しており、テスト中に時間の経過を制御することができます。これは、時間依存のコードをテストするのに役立ちます。さらに、Effectは`TestRandom`ユーティリティを提供しており、ランダム性を含むコードの完全に決定論的なテストを可能にします。これにより、一貫性のある予測可能なテスト結果が得られます。もう一つの便利なツールは`ConfigProvider.fromMap`であり、テスト中にアプリケーションのモック設定を簡単に定義することができます。

### Resource Management

Effectライブラリはリソース管理のためのビルトイン機能を提供していますが、fp-tsはこの分野では限られた機能（主に`bracket`）しか持たず、それらはあまり洗練されていません。

Effectにおけるリソース管理は、データベース接続、ファイルハンドル、ネットワークソケットなどのリソースを安全かつ制御された方法で取得および解放する能力を指します。ライブラリは、リソースの取得と解放を処理するための包括的かつ洗練されたメカニズムを提供し、適切なクリーンアップを保証し、リソースリークを防ぎます。

### Interruptions

Effectライブラリは中断をサポートしており、必要に応じて進行中の計算を中断およびキャンセルすることができます。この機能により、コードの実行をより制御でき、計算が完了する前に停止したい状況に対処できます。

Effectでは、中断はユーザーのキャンセル、タイムアウト、または進行中の計算を停止する必要がある他の外部イベントを処理するシナリオで役立ちます。中断を明示的に要求することができ、ライブラリは計算の実行を安全かつ効率的に停止します。

一方、fp-tsには中断をサポートするビルトイン機能はありません。fp-tsで計算が開始されると、完了するかエラーに遭遇するまで続行され、中断することはできません。

### Defects

Effectライブラリは、欠陥を処理し、予期しない失敗を管理するためのメカニズムを提供しています。Effectにおける欠陥とは、プログラムの実行中に発生する予期しないエラーや失敗を指します。

Effectライブラリには、欠陥を構造化された信頼性のある方法で処理するためのビルトインツールとユーティリティが用意されています。例外をキャッチして処理し、失敗から回復し、予期しないシナリオを優雅に処理するためのエラーハンドリング機能を提供しています。

一方、fp-tsには欠陥を管理するための専用のビルトインサポートはありません。fp-tsでは標準的な関数型プログラミング技術を使用してエラーを処理できますが、Effectライブラリは欠陥に対処するためのより包括的で合理化されたアプローチを提供しています。

### Fiber-Based Concurrency

Effectライブラリはファイバーベースの並行処理を活用しており、軽量で効率的な並行計算を可能にします。簡単に言えば、ファイバーベースの並行処理により、複数のタスクを同時に実行でき、コードをより応答性が高く効率的にします。

ファイバーベースの並行処理により、Effectライブラリは他のタスクの実行をブロックせずに並行操作を処理できます。これにより、複数の計算を同時に実行し、利用可能なリソースを活用してパフォーマンスを最大化できます。

一方、fp-tsにはファイバーベースの並行処理をサポートするビルトイン機能はありません。fp-tsは豊富な関数型プログラミング機能を提供していますが、Effectライブラリと同じレベルの並行計算サポートはありません。

### Fiber Supervision

Effectライブラリは、ファイバの管理と監視のための監督戦略を提供しています。fp-tsにはファイバ監督のビルトインサポートはありません。

### Retry and Retry Policies

Effectライブラリには、カスタマイズ可能なリトライポリシーを使用して計算をリトライするためのビルトインサポートが含まれています。この機能はfp-tsには標準で提供されておらず、同様の機能を実現するには外部ライブラリに依存する必要があります。ただし、外部ライブラリはEffectライブラリが提供するビルトインリトライ機能と同じレベルの洗練度や微調整を提供しない場合があります。

リトライ機能により、失敗した場合に計算やアクションを自動的にリトライすることができます。これは、ネットワークリクエストや外部サービスなどの信頼性の低いリソースを扱うシナリオで特に役立ちます。

Effectライブラリは、特定のニーズに合わせてカスタマイズできる包括的なリトライポリシーを提供しています。これらのポリシーは、計算をリトライする条件（リトライ回数、リトライ間の遅延、リトライを試みるかどうかを判断する基準など）を定義します。

Effectライブラリのビルトインリトライ機能を活用することで、一時的なエラーや一時的な失敗をより堅牢かつ回復力のある方法で処理できます。これにより、特に外部システムやサービスとやり取りする必要があるシナリオで、アプリケーションの全体的な信頼性と安定性を向上させることができます。

対照的に、fp-tsには計算をリトライするためのビルトインサポートはありません。fp-tsでリトライ機能が必要な場合は、外部ライブラリに依存する必要があり、これらのライブラリはEffectライブラリと同じレベルの洗練度や柔軟性を提供しない場合があります。

Effectライブラリのビルトインリトライ機能は、エラーハンドリングやリソース管理などの他の機能とシームレスに連携するように設計されていることに注意する価値があります。この統合により、計算内の失敗やリトライを処理するためのより一貫性のある包括的なアプローチが可能になります。

### Built-in Logging

Effectライブラリにはビルトインのロギング機能が備わっています。これにより、追加のライブラリや依存関係を必要とせずに、アプリケーションにロギングを簡単に組み込むことができます。さらに、Effectが提供するデフォルトのロガーは、特定のロギング要件に合わせてカスタムロガーに置き換えることができます。

ロギングは、コードの実行中に重要な情報を記録および追跡するためのソフトウェア開発の重要な側面です。アプリケーションの動作を監視し、問題をデバッグし、分析のための洞察を収集するのに役立ちます。

Effectライブラリのビルトインロギング機能を使用すると、コードのさまざまなポイントでメッセージ、警告、エラー、またはその他の関連情報を簡単にログに記録できます。これにより、実行の流れを追跡し、潜在的な問題を特定し、アプリケーションの操作中の重要なイベントをキャプチャするのに特に役立ちます。

一方、fp-tsにはビルトインのロギング機能は提供されていません。fp-tsでロギング機能が必要な場合は、外部ライブラリに依存するか、独自のロギングソリューションをゼロから実装する必要があります。これにより、コードベースに追加の複雑さと依存関係が導入される可能性があります。

### Built-in Scheduling

Effectライブラリはビルトインのスケジューリング機能を提供しており、計算の実行を時間的に管理することができます。この機能はfp-tsには提供されていません。

多くのアプリケーションでは、特定の間隔で実行する必要があるタスクや計算、または将来の実行のためにスケジュールされるタスクや計算が一般的です。例えば、定期的なデータ更新、通知のトリガー、特定の時間にバックグラウンドプロセスを実行するなどです。ここでビルトインのスケジューリングが役立ちます。

一方、fp-tsにはビルトインのスケジューリング機能はありません。fp-tsでタスクをスケジュールしたり、時間に基づいた計算を管理する必要がある場合は、外部ライブラリに依存するか、独自のスケジューリングメカニズムを実装する必要があり、これによりコードベースが複雑になる可能性があります。

### Built-in Caching

Effectライブラリはビルトインのキャッシング機能を提供しており、計算結果をキャッシュしてパフォーマンスを向上させることができます。この機能はfp-tsには提供されていません。

多くのアプリケーションでは、特に複雑な操作やリモートリソースへのアクセスを扱う場合、計算が時間を要するかリソースを消費することがあります。キャッシングは、計算結果を保存して、毎回再計算することなく迅速に取得できるようにするための技術です。

Effectライブラリのビルトインキャッシング機能を使用すると、計算結果を簡単にキャッシュし、必要に応じて再利用できます。これにより、冗長な計算を回避し、外部リソースへの負荷を軽減することで、アプリケーションのパフォーマンスを大幅に向上させることができます。

### Built-in Batching

Effectライブラリはビルトインのバッチ処理機能を提供しており、複数の計算を単一のバッチ計算にまとめることができます。この機能はfp-tsには提供されていません。

多くのシナリオでは、類似の入力や依存関係を共有する複数の計算を実行する必要があります。これらの計算を個別に実行すると、非効率性やオーバーヘッドが増加する可能性があります。バッチ処理は、これらの計算をグループ化して単一のバッチとして実行することで、パフォーマンスを向上させ、不要な処理を削減するための技術です。

### Metrics

Effectライブラリには、計算やシステムの動作に関連するメトリクスを収集および報告するためのビルトインサポートが含まれています。特に[OpenTelemetry Metrics](https://opentelemetry.io/docs/specs/otel/metrics/)をサポートしています。この機能はfp-tsには提供されていません。

メトリクスは、アプリケーションのパフォーマンスや動作を理解し、監視するために重要な役割を果たします。応答時間、リソース使用率、エラー率など、さまざまな側面に関する貴重な洞察を提供します。メトリクスを収集して分析することで、パフォーマンスのボトルネックを特定し、コードを最適化し、アプリケーションの全体的な品質を向上させるための情報に基づいた意思決定を行うことができます。

### Tracing

Effectライブラリにはビルトインのトレーシング機能があり、コードの実行をトレースしてデバッグし、アプリケーション内のリクエストの経路を追跡することができます。さらに、EffectはOpenTelemetry観測フレームワークと統合するための専用の[OpenTelemetryエクスポーター](https://opentelemetry.io/docs/instrumentation/js/exporters/)を提供しています。対照的に、fp-tsにはコード実行の可視性を向上させるための同様のトレーシングツールは提供されていません。

### Configuration

Effectライブラリは、計算内で構成値を管理およびアクセスするためのビルトインサポートを提供しています。この機能はfp-tsには提供されていません。

構成値は、ソフトウェア開発の重要な側面です。コードを変更せずにアプリケーションの動作をカスタマイズすることができます。構成値の例としては、データベース接続文字列、APIエンドポイント、機能フラグ、および環境やデプロイメントによって異なるさまざまな設定が含まれます。
Effectライブラリのビルトイン構成サポートを使用すると、計算内でこれらの値を簡単に管理およびアクセスできます。構成値をロード、検証、およびアクセスするための便利なユーティリティと抽象化を提供し、アプリケーションが正しく機能するために必要な設定を確実に持つことができます。

Effectライブラリのビルトイン構成サポートを活用することで、以下のことが可能になります：

- 環境変数、構成ファイル、リモート構成プロバイダーなど、さまざまなソースから構成値をロードする。
- ロードされた構成値が期待される形式と構造に準拠していることを検証する。
- 計算内で構成値にアクセスし、必要な場所で使用する。

### Immutable Data Structures

Effectライブラリは、`Chunk`、`HashSet`、`HashMap`などのimmutableデータ構造をビルトインでサポートしています。これらのデータ構造は、一度作成されるとその値を変更できないため、より安全で予測可能なコードを促進します。対照的に、fp-tsにはこれらのデータ構造のビルトインサポートはなく、標準データ型（`Set`や`Map`）に追加のAPIを提供するモジュールのみが含まれています。

immutableデータ構造には以下の利点があります：

- 不変性: immutableデータ構造は作成後に変更できません。この特性により、偶発的な変更のリスクが排除され、より安全な並行プログラミングが可能になります。

- 予測可能性: immutableデータ構造を使用すると、その値が予期せず変更されないことを信頼できます。この予測可能性により、コードの動作を簡単に理解でき、可変状態によるバグが減少します。

- 共有と再利用: immutableデータ構造はプログラムの異なる部分間で安全に共有できます。変更できないため、防御的なコピーを作成する必要がなくなり、メモリ使用効率が向上し、パフォーマンスが改善されます。

一方、fp-tsにはこれらの特定のimmutableデータ構造のビルトインサポートはありません。代わりに、標準のJavaScriptデータ型（`Set`や`Map`）の機能を拡張するモジュールを提供しています。これらのモジュールは有用ですが、Effectライブラリが提供するビルトインのimmutableデータ構造と同じレベルのパフォーマンス最適化や専門的な操作は提供しません。

### Stream Processing

Effectエコシステムは、ストリーム処理をビルトインでサポートしており、データのストリームを扱うことができます。ストリーム処理は、連続的なデータストリームを効率的に処理および変換するための強力な概念であり、リアクティブかつ非同期的な方法で行われます。しかし、fp-tsにはこの機能がビルトインされておらず、ストリーム処理を扱うためにはRxJSのような外部ライブラリに依存しています。
