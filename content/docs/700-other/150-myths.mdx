---
title: 誤解
excerpt: Effectに関する一般的な誤解について議論します。
bottomNavigation: pagination
---

## Effectはジェネレータに大きく依存しており、ジェネレータは遅い！

Effectの内部はジェネレータで構築されているわけではありません。ジェネレータはasync-awaitに非常に似たAPIを提供するために使用しています。内部的にはasync-awaitはジェネレータと同じメカニズムを使用しており、パフォーマンスも同等です。したがって、async-awaitに問題がなければ、Effectのジェネレータにも問題はありません。

ジェネレータとイテラブルが許容できないほど遅いのは、データのコレクションを変換する場合です。そのため、可能な限りプレーンな配列を使用するようにしてください。

## Effectはコードを500倍遅くします！

Effectは、次のように比較すると500倍遅くなります。

```ts
const result = 1 + 1
```

to

```ts
const result = Effect.runSync(
  Effect.zipWith(Effect.succeed(1), Effect.succeed(1), (a, b) => a + b)
)
```

理由は、一方の操作はJITコンパイラによって直接CPU命令に最適化されているのに対し、もう一方はそうではないからです。

実際には、このような場合にEffectを使用することはありません。Effectは、並行処理やエラーハンドリングなどを制御するためのアプリレベルのライブラリです。

Effectを使用してコードのスンクを調整し、Effectを通じて実行を制御しながら、最もパフォーマンスの良い方法でスンクを構築することができます。

## Effectは大きなパフォーマンスオーバーヘッドがあります！

パフォーマンスの意味によりますが、多くの場合、JSのパフォーマンスボトルネックは並行処理の管理が悪いために発生します。

構造化された並行処理と観測可能性のおかげで、これらの問題を見つけて最適化するのがはるかに簡単になります。

フロントエンドで120fpsで動作するアプリもあり、Effectを集中的に使用していますので、Effectがパフォーマンスの問題になることはほとんどありません。

メモリに関しては、通常のプログラムと比べてそれほど多くのメモリを使用しません。非Effectコードと同じことを行う場合、通常は非Effectコードと比べていくつかの追加のメモリ割り当てがありますが、これはもはや問題ではありません。

アドバイスとしては、まず使用してみてコードを監視し、必要に応じて最適化することです。考えなしに最適化するのではなく、必要に応じて最適化することがソフトウェア設計のすべての悪の根源です。

## バンドルサイズが巨大です！

Effectの最小コストは約25kのgzip圧縮コードです。このチャンクにはEffect Runtimeが含まれており、通常のアプリコードシナリオで必要なほとんどの関数がすでに含まれています。

その時点から、Effectはツリーシェイキングに対応しているため、使用するものだけを含めることができます。

また、Effectを使用すると自分のコードが短くなり、全体のコストが使用とともに相殺されます。コードベースの大部分でEffectを採用した結果、最終的なバンドルが減少したアプリもあります。

## Effectは学ぶのが不可能です。関数やモジュールが多すぎます！

確かに、Effectのエコシステム全体は非常に大きく、一部のモジュールには数千の関数が含まれています。しかし、すべてを知る必要はなく、10〜20の関数を知っていれば生産的に使用を開始でき、徐々に他の関数を発見していくことができます。これは、すべてのNPMパッケージを知らなくてもTypeScriptを使い始めることができるのと同じです。

一般的に使用される関数の短いリストは次のとおりです：

- Effect.succeed
- Effect.fail
- Effect.sync
- Effect.tryPromise
- Effect.gen
- Effect.runPromise
- Effect.catchTag
- Effect.catchAll
- Effect.acquireRelease
- Effect.acquireUseRelease
- Effect.provide
- Effect.provideService
- Effect.andThen
- Effect.map
- Effect.tap

一般的に使用されるモジュールの短いリスト：

- Effect
- Context
- Layer
- Option
- Either
- Array
- Match

## EffectはRxJSと同じで、その問題を共有しています

これはデリケートなトピックです。まず、RxJSは素晴らしいプロジェクトであり、何百万もの開発者が信頼性の高いソフトウェアを書くのを助けてきたことに感謝すべきです。

プロジェクトの範囲を議論すると、RxJSはObservablesを扱いやすくし、JSにリアクティブ拡張を提供することを目指しています。一方、EffectはプロダクションレベルのTypeScriptを書くのを容易にすることを目指しています。交差する部分はありますが、プロジェクトの目的と戦略は根本的に異なります。

時々、RxJSが悪い光で見られることがありますが、その理由はRxJS自体ではなく、RxJSが意図されていない問題領域で使用されることにあります。

具体的には、「すべてがストリームである」という考え方は理論的には正しいですが、開発者の経験に根本的な制限をもたらします。主な問題は、ストリームがマルチショット（複数の要素を発行する可能性がある）であり、可変の区切られた継続（JSジェネレータ）は単一ショットのエフェクト（単一の値を発行する）を表現するのに適していることです。

要するに、命令型スタイル（async/awaitを考えてください）で書くことは、ストリームプリミティブでは実質的に不可能です（実際には、ジェネレータを各要素および各ステップで再生するオプションがありますが、これは非効率的であり、その意味は直感に反します。完全な本体が副作用のないことを前提とする場合にのみ機能します）。これにより、開発者はすべてのコードを表現するために宣言型アプローチ（pipeなど）を使用することを余儀なくされます。

EffectにはStreamモジュールがあります（メモリを一定に保つためにプルベースです）が、基本的なEffectタイプは単一ショットであり、スマートで遅延評価されるPromiseとして最適化されているため、Effectを使用する際にはすべてのものに宣言型スタイルを使用する必要はなく、async-awaitに似たモデルを使用してプログラムすることができます。

もう一つの大きな違いは、RxJSはハッピーパスのみを明示的な型で扱い、エラーや依存関係を型付けする方法を提供しないことです。一方、Effectはエラーと依存関係の両方を明示的に型付けし、それらを完全に型安全な方法で制御するフローを提供します。

要するに、Observablesを中心にリアクティブプログラミングが必要な場合はRxJSを使用し、ネイティブのテレメトリー、エラーハンドリング、依存性注入などを含むプロダクションレベルのTypeScriptを書く必要がある場合はEffectを使用してください。

## Effectは言語であるべき、または別の言語を使用すべき

どちらもTypeScriptでプロダクションレベルのソフトウェアを書く問題を解決しません。

TypeScriptは、JSエコシステムに深く根ざし、ツールの広範な互換性を持つフルスタックコードを書くための素晴らしい言語です。多くの大規模な企業に採用されている産業言語です。

Effectのようなものが言語内で可能であり、ジェネレータのようなものをサポートしているため、Effectのようなカスタムタイプを使用した命令型プログラミングが可能であるという事実は、TypeScriptをユニークな言語にしています。

実際、Scalaのような関数型言語でも、エフェクトシステムとの相互運用性はTypeScriptほど最適ではなく、エフェクトシステムの著者が自分たちの言語がTypeScriptと同じくらいサポートしてほしいと表明しているほどです。
