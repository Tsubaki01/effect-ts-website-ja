---
title: Runtimeの紹介
excerpt: Effectは、開発者が複雑な同期および非同期プログラムを簡単に作成できるように設計された強力なTypeScriptライブラリです。
bottomNavigation: pagination
---

`Runtime<R>`データ型は、エフェクトを実行できるランタイムシステムを表します。任意のエフェクトを実行するには、そのエフェクトに必要な要件を含む`Runtime`が必要です。

`Runtime<R>`は、以下の3つの主要なコンポーネントで構成されています：

- `Context<R>`型の値
- `FiberRefs`型の値
- `RuntimeFlags`型の値

## デフォルトランタイム

`Effect.run*`のような関数を使用する場合、実際には**デフォルトランタイム**を明示的に言及せずに使用しています。これらの関数は、デフォルトランタイムを使用してエフェクトを実行するための便利なショートカットとして設計されています。

例えば、`Runtime`モジュールには、`Effect.run*`によって内部的に呼び出される対応する`Runtime.run*(defaultRuntime)`関数があります。例えば、`Effect.runSync`は単に`Runtime.runSync(defaultRuntime)`のエイリアスです。

デフォルトランタイムには以下が含まれます：

- 空の`Context<never>`
- デフォルトサービスを含む`FiberRefs`のセット
- `Interruption`と`CooperativeYielding`を有効にする`RuntimeFlags`のデフォルト設定

ほとんどの場合、デフォルトランタイムを使用するだけで十分です。しかし、特定のコンテキストや設定を再利用するためにカスタムランタイムを作成することが有用な場合もあります。`Layer<R, Err, RIn>`を初期化することで`Runtime<R>`を作成することが一般的です。これにより、ReactアプリやAPIリクエストに応答するサーバー上での操作など、実行境界を越えたコンテキストの再利用が可能になります。

## ランタイムシステムとは？

Effectプログラムを書くとき、コンストラクタやコンビネータを使用して`Effect`を構築します。基本的に、プログラムの設計図を作成しています。`Effect`は、並行プログラムの実行を記述するデータ構造に過ぎません。これは、`Effect`が何をすべきかを定義するためにさまざまなプリミティブを組み合わせた木構造を表します。

しかし、このデータ構造自体は何のアクションも実行しません。それは単に並行プログラムの記述です。

したがって、Effectのような関数型エフェクトシステムを使用する場合、コンソールへの出力、ファイルの読み取り、データベースのクエリなどのアクションのコードは、実際にはアプリケーションのワークフローや設計図を構築していることを理解することが重要です。私たちはデータ構造を構築しています。

では、Effectはこれらのワークフローをどのように実行するのでしょうか？ここでEffectランタイムシステムが登場します。`Runtime.run*`関数を呼び出すと、ランタイムシステムが引き継ぎます。まず、空のルートファイバーを作成します：

- 初期コンテキスト
- 初期fiberRefs
- 初期Effect

ファイバーの作成後、ファイバーのrunLoopを呼び出し、`Effect`で記述された指示に従ってステップバイステップで実行します。

簡単に言えば、ランタイムシステムは、エフェクト[Effect&lt;A, E, R&gt;](essentials/the-effect-type)とその関連コンテキスト`Context<R>`の両方を受け取り、エフェクトを実行して結果を[Exit&lt;A, E&gt;](../other/data-types/exit)値として返すブラックボックスとして考えることができます。

![Runtime](/images/mmd/runtime.svg)

## ランタイムシステムの責任

ランタイムシステムには多くの責任があります：

1. **設計図のすべてのステップを実行する**。設計図のすべてのステップをwhileループで完了するまで実行する必要があります。

2. **予期しないエラーを処理する**。予期されたエラーだけでなく、予期しないエラーも処理する必要があります。

3. **並行ファイバーを生成する**。エフェクトシステムが持つ並行性の責任を負います。エフェクトで`fork`を呼び出して新しいファイバーを生成するたびに、ファイバーを生成する必要があります。

4. **他のファイバーに協力的に譲る**。他のファイバーに協力的に譲る必要があります。これにより、リソースを独占しないようにします。

5. **ファイナライザを適切に実行する**。すべての状況でリソースが閉じられ、クリーンアップロジックが実行されるように、適切なタイミングでファイナライザを実行する必要があります。これは[Scope](./resource-management/scope)やEffectの他のリソースセーフな構造を支える機能です。

6. **非同期コールバックを処理する**。非同期コールバックを処理するという厄介な仕事を引き受ける必要があります。Effectを使用する場合、すべてが非同期または同期として解釈されることができます。

## デフォルトランタイム

Effectは、主流の使用を目的とした`Runtime.defaultRuntime`というデフォルトランタイムを提供します。

デフォルトランタイムは、Effectタスクの実行をブートストラップするための最小限の機能を提供します。

以下の2つの実行は同等です：

```ts twoslash
import { Effect, Runtime } from "effect"

const program = Effect.log("Application started!")

Effect.runSync(program)
/*
出力:
... level=INFO fiber=#0 message="Application started!"
*/

Runtime.runSync(Runtime.defaultRuntime)(program)
/*
出力:
... level=INFO fiber=#0 message="Application started!"
*/
```

内部的には、`Effect.runSync`（および他の`Effect.run*`関数にも同じ原則が適用されます）は、`Runtime.runSync(Runtime.defaultRuntime)`の便利な省略形として機能します。

## ローカルスコープのランタイム設定

Effectでは、ランタイム設定は通常、親ワークフローから継承されます。つまり、ワークフロー内でランタイム設定にアクセスしたりランタイムを取得したりする場合、基本的には親ワークフローの設定を使用しています。しかし、コードの特定の部分に対して一時的にランタイム設定を上書きしたい場合があります。この概念はローカルスコープのランタイム設定と呼ばれます。そのコード領域の実行が完了すると、ランタイム設定は元の設定に戻ります。

これを実現するために、`Effect.provide*`関数を使用して、コードの特定のセクションに新しいランタイム設定を提供します。

### 設定レイヤーを提供してランタイムを設定する

`Effect.provide`関数を利用し、Effectワークフローにランタイム設定レイヤーを提供することで、ランタイム設定を簡単に変更できます。

以下はその例です：

```ts twoslash
import { Logger, Effect } from "effect"

// Define a configuration layer
const addSimpleLogger = Logger.replace(
  Logger.defaultLogger,
  Logger.make(({ message }) => console.log(message))
)

const program = Effect.gen(function* () {
  yield* Effect.log("Application started!")
  yield* Effect.log("Application is about to exit!")
})

Effect.runSync(program)
/*
出力:
timestamp=... level=INFO fiber=#0 message="Application started!"
timestamp=... level=INFO fiber=#0 message="Application is about to exit!"
*/

// Overriding the default logger
Effect.runSync(program.pipe(Effect.provide(addSimpleLogger)))
/*
出力:
Application started!
Application is about to exit!
*/
```

この例では、まず`Logger.replace`を使用してシンプルなロガーのための設定レイヤーを作成します。
次に、`Effect.provide`を使用してこの設定をプログラムに提供し、デフォルトのロガーをシンプルなロガーに効果的に上書きします。

ランタイム設定がEffectアプリケーションの特定の部分にのみ適用されるようにするためには、次の例で示されているように、その特定のセクションにのみ設定レイヤーを提供する必要があります。

```ts twoslash
import { Logger, Effect } from "effect"

// 設定レイヤーを定義する
const addSimpleLogger = Logger.replace(
  Logger.defaultLogger,
  Logger.make(({ message }) => console.log(message))
)

const program = Effect.gen(function* () {
  yield* Effect.log("Application started!")
  yield* Effect.gen(function* () {
    yield* Effect.log("I'm not going to be logged!")
    yield* Effect.log("I will be logged by the simple logger.").pipe(
      Effect.provide(addSimpleLogger)
    )
    yield* Effect.log(
      "Reset back to the previous configuration, so I won't be logged."
    )
  }).pipe(Effect.provide(Logger.remove(Logger.defaultLogger)))
  yield* Effect.log("Application is about to exit!")
})

Effect.runSync(program)
/*
出力:
timestamp=... level=INFO fiber=#0 message="Application started!"
I will be logged by the simple logger.
timestamp=... level=INFO fiber=#0 message="Application is about to exit!"
*/
```

## トップレベルのランタイム設定

Effectアプリケーションを開発し、`Effect.run*`関数を使用して実行する際、アプリケーションは裏側でデフォルトのランタイムを使用して自動的に実行されます。
`Effect.provide`操作を使用してローカルにスコープされた設定レイヤーを提供することで、Effectアプリケーションの特定の側面を調整およびカスタマイズできますが、
アプリケーション全体のランタイム設定をトップレベルからカスタマイズする必要があるシナリオもあります。

このような状況では、`ManagedRuntime.make`コンストラクタを使用して設定レイヤーをランタイムに変換することで、トップレベルのランタイムを作成できます。

### ManagedRuntime

```ts twoslash
import { Effect, ManagedRuntime, Logger } from "effect"

// 設定レイヤーを定義する
const appLayer = Logger.replace(
  Logger.defaultLogger,
  Logger.make(({ message }) => console.log(message))
)

// 設定レイヤーをランタイムに変換する
const runtime = ManagedRuntime.make(appLayer)

const program = Effect.log("Application started!")

// カスタムランタイムを使用してプログラムを実行
runtime.runSync(program)

// 設定レイヤーで使用されたリソースをクリーンアップ
Effect.runFork(runtime.disposeEffect)
/*
出力:
Application started!
*/
```

この例では、まず`appLayer`というカスタム設定レイヤーを作成し、ロガーの設定を変更しています。
次に、この設定レイヤーを`ManagedRuntime.make`を使用してランタイムに変換します。
これにより、Effectアプリケーション全体に対して望ましい設定をカプセル化したトップレベルのランタイムが生成されます。

トップレベルのランタイム設定をカスタマイズすることで、Effectアプリケーション全体の動作を特定のニーズや要件に合わせて調整することができます。

### Effect.Tag

渡し回るランタイムを使用する場合、`Effect.Tag`を使用して新しいタグを定義し、サービスへのアクセスを簡素化できます。これにより、サービスの形状がタグクラスの静的側に直接組み込まれます。

以下のように`Effect.Tag`を使用して新しいタグを定義できます：

```ts twoslash
import { Effect } from "effect"

class Notifications extends Effect.Tag("Notifications")<
  Notifications,
  { readonly notify: (message: string) => Effect.Effect<void> }
>() {}
```

このセットアップでは、サービスの形状の各フィールドが`Notifications`クラスの静的プロパティに変換されます。

これにより、サービスの形状に直接アクセスできるようになります：

```ts twoslash
import { Effect } from "effect"

class Notifications extends Effect.Tag("Notifications")<
  Notifications,
  { readonly notify: (message: string) => Effect.Effect<void> }
>() {}

// ---cut---
const action = Notifications.notify("Hello, world!")
```

ご覧のとおり、`action`は`Notifications`に依存していますが、これは問題ではありません。後で`Notifications`を提供する`Layer`を構築し、それを使って`ManagedRuntime`を作成することができるからです。

### 統合

`ManagedRuntime`は、Effectが主要なフレームワークではなく、メインエントリーポイントへのアクセスが制限されている環境で、特にサービスやレイヤーを他のフレームワークやツールと統合することを簡素化します。

例えば、`ManagedRuntime`は、Reactやその他のフレームワークのように、アプリケーションのメインエントリーポイントの制御が限られている環境で特に有用です。以下は、外部フレームワーク内でサービスのライフサイクルを管理するために`ManagedRuntime`を使用する方法です：

```ts twoslash
import { Effect, ManagedRuntime, Layer, Console } from "effect"

class Notifications extends Effect.Tag("Notifications")<
  Notifications,
  { readonly notify: (message: string) => Effect.Effect<void> }
>() {
  static Live = Layer.succeed(this, {
    notify: (message) => Console.log(message)
  })
}

// 外部フレームワークのエントリーポイントの例
async function main() {
  const runtime = ManagedRuntime.make(Notifications.Live)
  await runtime.runPromise(Notifications.notify("Hello, world!"))
  await runtime.dispose()
}
```
