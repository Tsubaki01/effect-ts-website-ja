---
title: Effectのインポート
excerpt: "`effect`パッケージをインストールし、モジュールのインポートを探索することで、Effectの使用を開始します。`Effect`モジュールのインポート方法、名前空間インポートの理解、Effectエコシステムでメソッドよりも関数を使用する利点を把握します。Effectの旅を始めるための強固な基盤を築くために、基本的な関数に焦点を当てます。"
bottomNavigation: pagination
---

Effectへようこそ！始めたばかりの方は、Effectが提供するさまざまなモジュールや関数に圧倒されるかもしれません。
しかし、すべてをすぐに理解する必要はないのでご安心ください。
このガイドでは、モジュールや関数のインポート方法について簡単に説明し、ほとんどの場合、`effect`パッケージをインストールするだけで十分であることをお伝えします。それでは始めましょう！

## Effectのインストール

Effectの旅を始めるには、まず`effect`パッケージをインストールする必要があります。ターミナルを開き、次のコマンドを実行してください：

<Tabs items={["npm", "pnpm", "yarn"]}>
<Tab>

```bash filename="Terminal"
npm install effect
```

</Tab>
<Tab>

```bash filename="Terminal"
pnpm add effect
```

</Tab>
<Tab>

```bash filename="Terminal"
yarn add effect
```

</Tab>
</Tabs>
このパッケージをインストールするだけで、Effectの基本機能にアクセスできます。

DenoやBunなどの他のプラットフォームでの詳細なインストール手順については、[クイックスタート](../../quickstart)チュートリアルを参照してください。
これにより、異なる環境でEffectをセットアップするためのステップバイステップのガイダンスが提供されます。

## モジュールと関数のインポート

`effect`パッケージをインストールしたら、そのモジュールや関数をプロジェクトで使用し始めることができます。
モジュールや関数のインポートは簡単で、標準的なJavaScript/TypeScriptのインポート構文に従います。

`effect`パッケージからモジュールや関数をインポートするには、ファイルの先頭に`import`文を使用します。以下は`Effect`モジュールをインポートする方法です：

```ts
import { Effect } from "effect"
```

これで、Effectライブラリの中心である`Effect`モジュールにアクセスできるようになりました。このモジュールは、エフェクトを伴う計算を作成、合成、操作するための様々な関数を提供しています。

## 名前空間インポート

前述のように、名前付きインポートで`Effect`モジュールをインポートすることに加えて、

```ts
import { Effect } from "effect"
```

このように名前空間インポートを使用してインポートすることもできます：

```ts
import * as Effect from "effect/Effect"
```

両方のインポート形式を使用すると、`Effect`モジュールが提供する機能にアクセスできます。

しかし、重要な考慮事項は**ツリーシェイキング**です。これは、アプリケーションのバンドル時に未使用のコードを削除するプロセスを指します。
名前付きインポートは、バンドラーが深いスコープ解析をサポートしていない場合、ツリーシェイキングの問題を引き起こす可能性があります。

以下は、深いスコープ解析をサポートしているため、名前付きインポートに問題がないバンドラーの例です：

- Rollup
- Webpack 5+

## 関数 vs メソッド

Effectエコシステムでは、ライブラリはメソッドではなく関数を公開することが多いです。この設計選択は、ツリーシェーキングと拡張性の2つの重要な理由から重要です。

### ツリーシェーキング

ツリーシェーキングとは、ビルドシステムがバンドルプロセス中に未使用のコードを排除する能力を指します。関数はツリーシェーキング可能ですが、メソッドはそうではありません。

Effectエコシステムで関数が使用される場合、実際にアプリケーションでインポートされ使用される関数のみが最終的なバンドルコードに含まれます。未使用の関数は自動的に削除され、バンドルサイズが小さくなり、パフォーマンスが向上します。

一方、メソッドはオブジェクトやプロトタイプにアタッチされているため、簡単にツリーシェーキングすることはできません。たとえ一部のメソッドしか使用しなくても、オブジェクトやプロトタイプに関連するすべてのメソッドがバンドルに含まれ、不要なコードの膨張を引き起こします。

### 拡張性

Effectエコシステムで関数を使用するもう一つの重要な利点は、拡張の容易さです。メソッドを使用する場合、既存のAPIの機能を拡張するには、オブジェクトのプロトタイプを変更する必要があり、これは複雑でエラーが発生しやすいです。

対照的に、関数を使用する場合、機能の拡張ははるかに簡単です。オブジェクトのプロトタイプを変更することなく、通常の関数として独自の「拡張メソッド」を定義できます。これにより、よりクリーンでモジュール化されたコードが促進され、他のライブラリやモジュールとの互換性も向上します。

<Idea>
  Effectエコシステムのライブラリで関数を使用することは、**ツリーシェーキング**を達成し、
  **拡張性**を確保するために重要です。関数は未使用のコードを排除することで効率的なバンドルを可能にし、
  ライブラリの機能を拡張するための柔軟でモジュール化されたアプローチを提供します。
</Idea>

## よく使われる関数

Effectの冒険を始めるにあたり、`effect`パッケージのすべての関数をすぐに理解する必要はありません。代わりに、Effectの世界への旅の基盤を提供するいくつかのよく使われる関数に焦点を当てましょう。

今後のガイドでは、特に`Effect`を作成し実行するための関数やパイプラインを構築するための基本的な関数について探求します。

しかし、その前に、Effectの中心である`Effect`型を理解することから始めましょう。これにより、Effectがどのようにしてコンポーザビリティ、型安全性、およびエラーハンドリングをアプリケーションにもたらすかの基礎が築かれます。

それでは、最初のステップを踏み出し、[The Effect Type](the-effect-type)の基本概念を探ってみましょう。
