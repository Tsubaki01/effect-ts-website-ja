---
title: パイプラインの構築
excerpt: 値に対する操作を構成およびシーケンス化するためのEffectパイプラインの力を探求します。モジュール化された簡潔な変換を構築するための主要な関数である`pipe`、`Effect.map`、`Effect.flatMap`、`Effect.andThen`、`Effect.tap`、`Effect.all`について学びます。Effectエコシステムにおいて、ツリーシェイクの可能性と拡張性のためにメソッドよりも関数を使用することの利点を理解します。
bottomNavigation: pagination
---

Effectパイプラインは、値に対する操作を構成およびシーケンス化することを可能にし、データの変換と操作を簡潔かつモジュール化された方法で行うことができます。

## パイプラインがアプリケーションの構造化に良い理由

パイプラインは、アプリケーションを構造化し、データ変換を簡潔かつモジュール化された方法で処理するための優れた方法です。以下のような利点があります：

1. **可読性**: パイプラインを使用すると、関数を読みやすく順序立てて構成できます。データの流れとそれに適用される操作が明確に見えるため、コードの理解と保守が容易になります。

2. **コードの整理**: パイプラインを使用すると、複雑な操作を小さく管理可能な関数に分解できます。各関数は特定のタスクを実行し、コードをよりモジュール化し、理解しやすくします。

3. **再利用性**: パイプラインは関数の再利用を促進します。操作を小さな関数に分解することで、異なるパイプラインやコンテキストでそれらを再利用でき、コードの再利用性が向上し、重複が減少します。

4. **型安全性**: 型システムを活用することで、パイプラインはコンパイル時にエラーをキャッチするのに役立ちます。パイプライン内の関数は明確に定義された入力と出力の型を持ち、データがパイプラインを通じて正しく流れることを保証し、ランタイムエラーを最小限に抑えます。

それでは、パイプラインの定義方法と主要なコンポーネントについて詳しく見ていきましょう：

## pipe

`pipe`関数は、関数を読みやすく順序立てて構成するためのユーティリティです。ある関数の出力を次の関数の入力として渡すことで、パイプライン内で複数の関数を連鎖させて複雑な変換を構築することができます。

`pipe`の基本的な構文は以下の通りです：

```ts
import { pipe } from "effect"

const result = pipe(input, func1, func2, ..., funcN)
```

この構文では、`input`が初期値であり、`func1`、`func2`、...、`funcN`が順番に適用される関数です。各関数の結果は次の関数の入力となり、最終的な結果が返されます。

以下は`pipe`の動作を示す図です：

![Pipe](/images/mmd/pipeline.svg)

`pipe`に渡される関数は**単一の引数**を持つ必要があることに注意してください。なぜなら、それらは単一の引数でのみ呼び出されるからです。

`pipe`の動作をよりよく理解するために、例を見てみましょう：

```ts twoslash
import { pipe } from "effect"

// 単純な算術演算を定義する
const increment = (x: number) => x + 1
const double = (x: number) => x * 2
const subtractTen = (x: number) => x - 10

// `pipe`を使用してこれらの操作を順次適用する
const result = pipe(5, increment, double, subtractTen)

console.log(result) // 出力: 2
```

上記の例では、入力値として`5`を使用しています。`increment`関数は初期値に`1`を加え、結果として`6`になります。次に、`double`関数が値を2倍にし、`12`になります。最後に、`subtractTen`関数が`12`から`10`を引き、最終的な出力は`2`になります。

この結果は `subtractTen(double(increment(5)))` と同等ですが、`pipe` を使用することでコードの可読性が向上します。なぜなら、操作が内側から外側へのネストではなく、左から右へ順序付けられているからです。

## 関数 vs メソッド

Effectエコシステムでは、ライブラリはメソッドではなく関数を公開することが多いです。この設計の選択は、ツリーシェイク可能性と拡張性という2つの重要な理由から重要です。

### ツリーシェイク可能性

ツリーシェイク可能性とは、ビルドシステムがバンドルプロセス中に未使用のコードを排除する能力を指します。関数はツリーシェイク可能ですが、メソッドはそうではありません。

Effectエコシステムで関数が使用される場合、実際にインポートされてアプリケーションで使用される関数のみが最終的なバンドルコードに含まれます。未使用の関数は自動的に削除され、バンドルサイズが小さくなり、パフォーマンスが向上します。

一方、メソッドはオブジェクトやプロトタイプにアタッチされており、簡単にツリーシェイクすることはできません。メソッドのサブセットのみを使用している場合でも、オブジェクトやプロトタイプに関連付けられたすべてのメソッドがバンドルに含まれ、不要なコードの膨張を引き起こします。

### 拡張性

Effectエコシステムで関数を使用することのもう一つの重要な利点は、拡張性の容易さです。メソッドを使用する場合、既存のAPIの機能を拡張するには、多くの場合オブジェクトのプロトタイプを変更する必要があり、これは複雑でエラーが発生しやすい可能性があります。

対照的に、関数を使用する場合、機能の拡張ははるかに簡単です。プロトタイプを変更する必要なく、通常の関数として独自の「拡張メソッド」を定義できます。これにより、よりクリーンでモジュール化されたコードが促進され、他のライブラリやモジュールとの互換性も向上します。

<Idea>
  Effectエコシステムのライブラリで関数を使用することは、**ツリーシェイク可能性**を実現し、
  **拡張性**を確保するために重要です。関数は未使用のコードを排除することで効率的なバンドリングを可能にし、
  ライブラリの機能を拡張するための柔軟でモジュール化されたアプローチを提供します。
</Idea>

それでは、`pipe`関数を使用してパイプラインを構築するために使用できるいくつかのAPIの例を見てみましょう。

## map

`Effect.map`関数は、`Effect`内の値を変換するために使用されます。
この関数は、`Effect`に含まれる値に適用され、新しい変換された値を持つ**新しい**`Effect`を作成します。

**Effect.mapの使用法**

`Effect.map`の構文は以下の通りです：

```ts
import { pipe, Effect } from "effect"

const mappedEffect = pipe(myEffect, Effect.map(transformation))
// or
const mappedEffect = Effect.map(myEffect, transformation)
// or
const mappedEffect = myEffect.pipe(Effect.map(transformation))
```

上記のコードで、`transformation`は値に適用される関数であり、`myEffect`は変換される`Effect`です。

<Info>
  `Effect`は不変であることに注意することが重要です。つまり、`Effect`に対して`Effect.map`を使用しても、
  元のデータ型は変更されません。代わりに、変換された値を持つ`Effect`の新しいコピーが返されます。
</Info>

**例**

取引に小額のサービス料を追加するプログラムを考えてみましょう：

```ts twoslash
import { pipe, Effect } from "effect"

// 取引金額に小額のサービス料を追加する関数
const addServiceCharge = (amount: number) => amount + 1

// データベースから取引金額を取得する模擬非同期タスク
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

// 取引金額にサービス料を適用する
const finalAmount = pipe(fetchTransactionAmount, Effect.map(addServiceCharge))

Effect.runPromise(finalAmount).then(console.log) // Output: 101
```

## as

元の値を置き換えて`Effect`を定数値にマッピングするには、`Effect.as`を使用します：

```ts twoslash
import { pipe, Effect } from "effect"

const program = pipe(Effect.succeed(5), Effect.as("new value"))

Effect.runPromise(program).then(console.log) // 出力: "new value"
```

## flatMap

`Effect.flatMap`関数は、`Effect`インスタンスを生成する変換をチェーンする必要がある場合に使用されます。
これは、非同期操作や前のエフェクトの結果に依存する計算に役立ちます。

**Effect.flatMapの使用法**

`Effect.flatMap`関数を使用すると、新しい`Effect`値を生成する計算を順序付けし、発生する可能性のある入れ子の`Effect`構造を「フラット化」することができます。

`Effect.flatMap`の構文は以下の通りです：

```ts
import { pipe, Effect } from "effect"

const flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))
// or
const flatMappedEffect = Effect.flatMap(myEffect, transformation)
// or
const flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))
```

上記のコードで、`transformation`は値を受け取り`Effect`を返す関数であり、`myEffect`は変換される初期の`Effect`です。

<Info>
  `Effect`は不変であることに注意することが重要です。つまり、`Effect`に対して
  `Effect.flatMap`を使用しても、元のデータ型は変更されません。代わりに、
  変換された値を持つ`Effect`の新しいコピーが返されます。
</Info>

**例**

```ts twoslash
import { pipe, Effect } from "effect"

// トランザクション金額に安全に割引を適用する関数
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// データベースからトランザクション金額を取得するシミュレートされた非同期タスク
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const finalAmount = pipe(
  fetchTransactionAmount,
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(finalAmount).then(console.log) // Output: 95
```

**すべての効果が考慮されていることを確認する**

`Effect.flatMap`内のすべての効果が最終的な計算に寄与していることを確認することが重要です。
効果を無視すると、予期しない動作や不正確な結果につながる可能性があります：

```ts {1}
Effect.flatMap((amount) => {
  Effect.sync(() => console.log(`Apply a discount to: ${amount}`)) // This effect is ignored
  return applyDiscount(amount, 5)
})
```

上記の`Effect.sync`は無視され、`applyDiscount(amount, 5)`の結果に影響を与えません。
エフェクトを適切に含め、エラーを避けるために、`Effect.map`、`Effect.flatMap`、`Effect.andThen`、または`Effect.tap`などの関数を使用して明示的に連鎖させてください。

**`flatMap`に関する追加情報**

多くの開発者は配列での使用から`flatMap`を認識しているかもしれませんが、`Effect`フレームワークでは、ネストされた`Effect`構造を管理および解決するために使用されます。
Effectの中でネストされた配列（`Effect<Array<Array<A>>>`）をフラット化することが目的の場合、以下のように行うことができます：

```ts twoslash
import { pipe, Effect, Array } from "effect"

const flattened = pipe(
  Effect.succeed([
    [1, 2],
    [3, 4]
  ]),
  Effect.map((nested) => Array.flatten(nested))
)
```

または標準の `Array.prototype.flat()` メソッドを使用します。

## andThen

`Effect.map`と`Effect.flatMap`の両方の関数は、2つの異なるシナリオで`Effect`を別の`Effect`に変換するために使用されます。
最初のシナリオでは、変換関数が`Effect`を返さない場合に`Effect.map`が使用され、2番目のシナリオでは、変換関数が`Effect`を返す場合に`Effect.flatMap`が使用されます。
しかし、両方のシナリオが変換を伴うため、Effectモジュールは便利なオールインワンソリューションとして`Effect.andThen`を提供しています。

`Effect.andThen`関数は、通常2つの`Effect`の一連のアクションを実行し、2番目のアクションは最初のアクションの結果に依存することができます。

```ts
import { pipe, Effect } from "effect"

const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))
// or
const transformedEffect = Effect.andThen(myEffect, anotherEffect)
// or
const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))
```

`anotherEffect`アクションは様々な形式を取ることができます：

1. 値（つまり、`Effect.as`と同じ機能）
2. 値を返す関数（つまり、`Effect.map`と同じ機能）
3. `Promise`
4. `Promise`を返す関数
5. `Effect`
6. `Effect`を返す関数（つまり、`Effect.flatMap`と同じ機能）

**例**

`Effect.map`や`Effect.flatMap`の代わりに`Effect.andThen`を使用する例を見てみましょう：

```ts
import { pipe, Effect } from "effect"

// トランザクション金額に安全に割引を適用する関数
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// データベースからトランザクション金額を取得する模擬非同期タスク
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

// Effect.map、Effect.flatMapを使用
const result1 = pipe(
  fetchTransactionAmount,
  Effect.map((amount) => amount * 2),
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(result1).then(console.log) // 出力: 190

// Effect.andThenを使用
const result2 = pipe(
  fetchTransactionAmount,
  Effect.andThen((amount) => amount * 2),
  Effect.andThen((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(result2).then(console.log) // 出力: 190
```

[Option](../../other/data-types/option#interop-with-effect)と[Either](../../other/data-types/either#interop-with-effect)は、オプション値や単純なエラーシナリオを扱うために一般的に使用される型ですが、これらも`Effect.andThen`と互換性があることに注目する価値があります。
ただし、これらの型を使用する場合、操作は前述のシナリオ5と6に分類されることを理解することが重要です。なぜなら、`Option`と`Either`はこのコンテキストでは`Effect`として機能するからです。

**Optionを使用した例**

```ts twoslash
import { pipe, Effect, Option } from "effect"

// データベースから数値を取得する模擬非同期タスク
const fetchNumberValue = Effect.promise(() => Promise.resolve(42))

// 型がEffect<Option<number>, never, never>になると予想されるかもしれませんが、
// 実際にはEffect<number, NoSuchElementException, never>になります
const program = pipe(
  fetchNumberValue,
  Effect.andThen((x) => (x > 0 ? Option.some(x) : Option.none()))
)
```

`Option<A>`型の値は`Effect<A, NoSuchElementException>`型のエフェクトとして解釈されます。

**Eitherを使用した例**

```ts twoslash
import { pipe, Effect, Either } from "effect"

// 文字列から整数を解析する関数（失敗する可能性あり）
const parseInteger = (input: string): Either.Either<number, string> =>
  isNaN(parseInt(input))
    ? Either.left("Invalid integer")
    : Either.right(parseInt(input))

// データベースから文字列を取得する模擬非同期タスク
const fetchStringValue = Effect.promise(() => Promise.resolve("42"))

// Effect<Either<number, string>, never, never>型になると予想されるかもしれませんが、
// 実際にはEffect<number, string, never>型になります
const program = pipe(
  fetchStringValue,
  Effect.andThen((str) => parseInteger(str))
)
```

`Either<A, E>`型の値は`Effect<A, E>`型のエフェクトとして解釈されます。

## tap

`Effect.tap` APIは`Effect.flatMap`と似たシグネチャを持ちますが、変換関数の結果は**無視されます**。
これは、前の計算で返された値が次の計算でもまだ利用可能であることを意味します。

**例**

```ts twoslash
import { pipe, Effect } from "effect"

// トランザクション金額に安全に割引を適用する関数
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// データベースからトランザクション金額を取得する模擬非同期タスク
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const finalAmount = pipe(
  fetchTransactionAmount,
  Effect.tap((amount) =>
    Effect.sync(() => console.log(`Apply a discount to: ${amount}`))
  ),
  // `amount` はまだ利用可能です！
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(finalAmount).then(console.log)
/*
Output:
Apply a discount to: 100
95
*/
```

`Effect.tap`を使用すると、計算中に結果を変更せずに副作用を実行できます。
これは、ログの記録、追加のアクションの実行、または主要な計算フローを妨げることなく中間値を観察するのに役立ちます。

## all

`Effect.all`関数は、複数のEffectを組み合わせて、結果のタプルを生成する単一のEffectにする強力なユーティリティです。

**Effect.allの使用法**

`Effect.all`の構文は以下の通りです：

```ts
import { Effect } from "effect"

const combinedEffect = Effect.all([effect1, effect2, ...])
```

`Effect.all`関数は、これらのエフェクトをすべて**順番に**実行します（並行性の管理やこれらのエフェクトの実行方法を制御するオプションについては、[並行性オプション](../concurrency/concurrency-options)のドキュメントを参照してください）。

この関数は、各個別のエフェクトの結果を含むタプルを生成する新しいエフェクトを返します。
結果の順序が`Effect.all`に渡された元のエフェクトの順序に対応していることに注意してください。

**例**

```ts twoslash
import { Effect } from "effect"

// ファイルから設定を読み込む模擬関数
const webConfig = Effect.promise(() =>
  Promise.resolve({ dbConnection: "localhost", port: 8080 })
)

// データベース接続性をテストする模擬関数
const checkDatabaseConnectivity = Effect.promise(() =>
  Promise.resolve("Connected to Database")
)

// 両方のエフェクトを組み合わせて起動時のチェックを実行する
const startupChecks = Effect.all([webConfig, checkDatabaseConnectivity])

Effect.runPromise(startupChecks).then(([config, dbStatus]) => {
  console.log(
    `Configuration: ${JSON.stringify(config)}, DB Status: ${dbStatus}`
  )
})
/*
出力:
Configuration: {"dbConnection":"localhost","port":8080}, DB Status: Connected to Database
*/
```

<Info>
  `Effect.all`関数はタプルを組み合わせるだけでなく、イテラブル、構造体、レコードにも対応しています。
  `all`の全ての可能性を探るには、[Effectの制御フロー演算子入門](../control-flow#all)のドキュメントをご覧ください。
</Info>

## 最初のパイプラインを構築する

それでは、`pipe`、`Effect.all`、`Effect.andThen`を組み合わせて、一連の変換を実行するパイプラインを構築してみましょう：

```ts twoslash
import { Effect, pipe } from "effect"

// トランザクション金額に小額のサービス料を追加する関数
const addServiceCharge = (amount: number) => amount + 1

// トランザクション金額に安全に割引を適用する関数
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// データベースからトランザクション金額を取得する模擬非同期タスク
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

// 設定ファイルから割引率を取得する模擬非同期タスク
const fetchDiscountRate = Effect.promise(() => Promise.resolve(5))

// エフェクトのパイプラインを使用してプログラムを組み立てる
const program = pipe(
  Effect.all([fetchTransactionAmount, fetchDiscountRate]),
  Effect.flatMap(([transactionAmount, discountRate]) =>
    applyDiscount(transactionAmount, discountRate)
  ),
  Effect.map(addServiceCharge),
  Effect.map((finalAmount) => `Final amount to charge: ${finalAmount}`)
)

// プログラムを実行し、結果をログに出力する
Effect.runPromise(program).then(console.log) // 出力: "Final amount to charge: 96"
```

## pipeメソッド

Effectは、[rxjs](https://rxjs.dev/api/index/function/pipe)に見られる`pipe`メソッドと同様に動作する`pipe`メソッドを提供します。このメソッドを使用すると、複数の操作を連鎖させることができ、コードをより簡潔で読みやすくすることができます。

以下は`pipe`**メソッド**の動作例です：

```ts
const result = effect.pipe(func1, func2, ..., funcN)
```

これは、次のように`pipe`**関数**を使用するのと同等です：

```ts
const result = pipe(effect, func1, func2, ..., funcN)
```

`pipe`メソッドはすべてのEffectおよび多くの他のデータ型で利用可能であり、`Function`モジュールから`pipe`関数をインポートする必要がなくなり、いくつかのキーストロークを節約できます。

前の例を`pipe`メソッドを使って書き直してみましょう：

```ts twoslash
import { Effect } from "effect"

const addServiceCharge = (amount: number) => amount + 1

const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const fetchDiscountRate = Effect.promise(() => Promise.resolve(5))

// ---cut---
const program = Effect.all([fetchTransactionAmount, fetchDiscountRate]).pipe(
  Effect.flatMap(([transactionAmount, discountRate]) =>
    applyDiscount(transactionAmount, discountRate)
  ),
  Effect.map(addServiceCharge),
  Effect.map((finalAmount) => `Final amount to charge: ${finalAmount}`)
)
```

## チートシート

これまでに見てきた変換関数をまとめましょう：

| **関数**  | **入力**                                  | **出力**                    |
| --------- | ----------------------------------------- | --------------------------- |
| `map`     | `Effect<A, E, R>`, `A => B`               | `Effect<B, E, R>`           |
| `flatMap` | `Effect<A, E, R>`, `A => Effect<B, E, R>` | `Effect<B, E, R>`           |
| `andThen` | `Effect<A, E, R>`, \*                     | `Effect<B, E, R>`           |
| `tap`     | `Effect<A, E, R>`, `A => Effect<B, E, R>` | `Effect<A, E, R>`           |
| `all`     | `[Effect<A, E, R>, Effect<B, E, R>, ...]` | `Effect<[A, B, ...], E, R>` |

これらの関数は、`Effect`の計算を変換および連鎖させるための強力なツールです。これにより、`Effect`内の値に関数を適用し、複雑な計算パイプラインを構築することができます。
