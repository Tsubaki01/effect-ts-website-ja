---
title: バッチ処理
excerpt: Effectは、開発者が複雑な同期および非同期プログラムを簡単に作成できるように設計された強力なTypeScriptライブラリです。
bottomNavigation: pagination
---

## APIインテグレーションの従来のアプローチ

一般的なアプリケーション開発では、外部API、データベース、または他のデータソースと対話する際、リクエストを実行し、その結果または失敗を適切に処理する関数を定義することがよくあります。

### シンプルなモデルのセットアップ

以下は、データの構造と発生し得るエラーの概要を示す基本的なモデルです：

```twoslash include Model
export interface User {
  readonly _tag: "User"
  readonly id: number
  readonly name: string
  readonly email: string
}

export class GetUserError {
  readonly _tag = "GetUserError"
}

export interface Todo {
  readonly _tag: "Todo"
  readonly id: number
  readonly message: string
  readonly ownerId: number
}

export class GetTodosError {
  readonly _tag = "GetTodosError"
}

export class SendEmailError {
  readonly _tag = "SendEmailError"
}
```

```ts filename="Model.ts" twoslash
// @include: Model
```

<Idea>
  実際のシナリオでは、識別子に直接プリミティブを使用するのではなく、
  より正確な型を使用したい場合があります（[ブランド型](style/branded-types)を参照）。
  さらに、エラーにはより詳細な情報を含めたい場合もあるでしょう。
</Idea>

### API関数の定義

外部APIと対話し、TODOの取得、ユーザー詳細の取得、メールの送信などの一般的な操作を処理する関数を定義しましょう。

```twoslash include API
import { Effect } from "effect"
import * as Model from "./Model"

// 外部APIからTODOリストを取得する
export const getTodos = Effect.tryPromise({
  try: () =>
    fetch("https://api.example.demo/todos").then(
      (res) => res.json() as Promise<Array<Model.Todo>>
    ),
  catch: () => new Model.GetTodosError()
})

// 外部APIからIDによってユーザーを取得する
export const getUserById = (id: number) =>
  Effect.tryPromise({
    try: () =>
      fetch(`https://api.example.demo/getUserById?id=${id}`).then(
        (res) => res.json() as Promise<Model.User>
      ),
    catch: () => new Model.GetUserError()
  })

// 外部APIを介してメールを送信する
export const sendEmail = (address: string, text: string) =>
  Effect.tryPromise({
    try: () =>
      fetch("https://api.example.demo/sendEmail", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ address, text })
      }).then((res) => res.json() as Promise<void>),
    catch: () => new Model.SendEmailError()
  })

// ユーザーの詳細を最初に取得してからメールを送信する
export const sendEmailToUser = (id: number, message: string) =>
  getUserById(id).pipe(
    Effect.andThen((user) => sendEmail(user.email, message))
  )

// TODOの所有者にメールを送信して通知する
export const notifyOwner = (todo: Model.Todo) =>
  getUserById(todo.ownerId).pipe(
    Effect.andThen((user) =>
      sendEmailToUser(user.id, `hey ${user.name} you got a todo!`)
    )
  )
```

```ts filename="API.ts" twoslash
// @filename: Model.ts
// @include: Model

// @filename: API.ts
// ---cut---
// @include: API
```

<Idea>
  実際のシナリオでは、APIが常に期待されるデータを返すと信頼しないかもしれません。
  このような場合、`@effect/schema`や`zod`のような代替手段を使用できます。
</Idea>

このアプローチは直感的で読みやすいですが、最も効率的ではないかもしれません。特に多くのTodoが同じ所有者を共有している場合、繰り返しのAPIコールはネットワークのオーバーヘッドを大幅に増加させ、アプリケーションを遅くする可能性があります。

### API関数の使用

これらの関数は明確で理解しやすいですが、その使用は最も効率的ではないかもしれません。例えば、Todo所有者への通知には繰り返しのAPIコールが含まれており、これは最適化できる可能性があります。

```ts filename="index.ts" twoslash
// @filename: Model.ts
// @include: Model

// @filename: API.ts
// @include: API

// @filename: index.ts
// ---cut---
import { Effect } from "effect"
import * as API from "./API"

// Todoの操作を調整し、所有者に通知する
const program = Effect.gen(function* () {
  const todos = yield* API.getTodos
  yield* Effect.forEach(todos, (todo) => API.notifyOwner(todo), {
    concurrency: "unbounded"
  })
})
```

この実装では、各todoに対して所有者の詳細を取得し、メールを送信するためのAPIコールを実行します。複数のtodoが同じ所有者を持つ場合、これは冗長なAPIコールを引き起こします。

### バッチコールによる効率性の向上

最適化するために、バックエンドがサポートしている場合はバッチAPIコールの実装を検討してください。これにより、複数の操作を1つのリクエストにグループ化することで、HTTPリクエストの数を減らし、パフォーマンスを向上させ、負荷を軽減します。

**次のステップ：**

可能な限りバッチ処理を使用するようにAPIの相互作用をリファクタリングします。これはサーバーの負荷を軽減するだけでなく、データの処理を効率化し、コードを効率的かつクリーンに保ちます。

## バッチング

APIコールのバッチングは、HTTPリクエストの数を減らすことで、アプリケーションのパフォーマンスを大幅に向上させることができます。

`getUserById`と`sendEmail`がバッチ処理可能だと仮定しましょう。これは、1回のHTTPコールで複数のリクエストを送信できることを意味し、APIリクエストの数を減らしてパフォーマンスを向上させます。

**バッチングのステップバイステップガイド**

1. **リクエストの構造化：** まず、リクエストを構造化されたデータモデルに変換します。これには、入力パラメータ、期待される出力、および可能性のあるエラーの詳細を含みます。このようにリクエストを構造化することで、データの効率的な管理だけでなく、異なるリクエストを比較して同じ入力パラメータを参照しているかどうかを理解するのに役立ちます。

2. **リゾルバの定義：** リゾルバは複数のリクエストを同時に処理するように設計されています。リクエストを比較する能力（同じ入力パラメータを参照していることを確認する）を活用することで、リゾルバは一度に複数のリクエストを実行し、バッチングの有用性を最大化できます。

3. **クエリの作成：** 最後に、これらのバッチリゾルバを利用して操作を実行するクエリを定義します。このステップでは、構造化されたリクエストとそれに対応するリゾルバをアプリケーションの機能的なコンポーネントにまとめます。

**重要な考慮事項**

リクエストが比較可能な方法でモデル化されることが重要です。これは、同一のリクエストを効果的に識別してバッチ処理するために、比較可能性（[Equals.equals](../other/trait/equal)のようなメソッドを使用）を実装することを意味します。

### リクエストの宣言

まず、データソースが処理できるリクエストの種類の構造化モデルを定義しましょう。データソースがサポートする可能性のある`Request`の概念を使用してモデルを設計します。

`Request<Value, Error>`は、`Value`型の値のリクエストを表す構造で、`Error`型のエラーで失敗する可能性があります。

```twoslash include Requests
import { Request } from "effect"
import * as Model from "./Model"

// GetTodosErrorで失敗する可能性のある複数のTodoアイテムを取得するリクエストを定義
export interface GetTodos
  extends Request.Request<Array<Model.Todo>, Model.GetTodosError> {
  readonly _tag: "GetTodos"
}

// GetTodosリクエスト用のタグ付きコンストラクタを作成
export const GetTodos = Request.tagged<GetTodos>("GetTodos")

// GetUserErrorで失敗する可能性のあるIDによるユーザー取得リクエストを定義
export interface GetUserById
  extends Request.Request<Model.User, Model.GetUserError> {
  readonly _tag: "GetUserById"
  readonly id: number
}

// GetUserByIdリクエスト用のタグ付きコンストラクタを作成
export const GetUserById = Request.tagged<GetUserById>("GetUserById")

// SendEmailErrorで失敗する可能性のあるメール送信リクエストを定義
export interface SendEmail
  extends Request.Request<void, Model.SendEmailError> {
  readonly _tag: "SendEmail"
  readonly address: string
  readonly text: string
}

// SendEmailリクエスト用のタグ付きコンストラクタを作成
export const SendEmail = Request.tagged<SendEmail>("SendEmail")

// 管理を容易にするために全てのリクエストをユニオン型に結合
export type ApiRequest = GetTodos | GetUserById | SendEmail
```

```ts filename="Requests.ts" twoslash
// @filename: Model.ts
// @include: Model

// @filename: Requests.ts
// ---cut---
// @include: Requests
```

各リクエストは、汎用的な`Request`型を拡張した特定のデータ構造で定義されており、各リクエストが固有のデータ要件と特定のエラー型を持つことを保証しています。

`Request.tagged`のようなタグ付きコンストラクタを使用することで、アプリケーション全体で認識可能で管理しやすいリクエストオブジェクトを簡単にインスタンス化できます。

### リゾルバの宣言

リクエストを定義した後、次のステップはEffectがこれらのリクエストを解決する方法を`RequestResolver`を使用して設定することです。`RequestResolver<A, R>`は環境`R`を必要とし、型`A`のリクエストを実行することができます。

このセクションでは、各種類のリクエストに対して個別のリゾルバを作成します。リゾルバの粒度は様々ですが、通常、対応するAPIコールのバッチ処理能力に基づいて分割されます。

```twoslash include Resolvers
import { Effect, RequestResolver, Request } from "effect"
import * as API from "./API"
import * as Model from "./Model"
import * as Requests from "./Requests"

// GetTodosはバッチ処理できないと仮定し、標準的なリゾルバを作成します。
export const GetTodosResolver = RequestResolver.fromEffect(
  (request: Requests.GetTodos) => API.getTodos
)

// GetUserByIdはバッチ処理できると仮定し、バッチリゾルバを作成します。
export const GetUserByIdResolver = RequestResolver.makeBatched(
  (requests: ReadonlyArray<Requests.GetUserById>) =>
    Effect.tryPromise({
      try: () =>
        fetch("https://api.example.demo/getUserByIdBatch", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            users: requests.map(({ id }) => ({ id }))
          })
        }).then((res) => res.json()) as Promise<Array<Model.User>>,
      catch: () => new Model.GetUserError()
    }).pipe(
      Effect.andThen((users) =>
        Effect.forEach(requests, (request, index) =>
          Request.completeEffect(request, Effect.succeed(users[index]))
        )
      ),
      Effect.catchAll((error) =>
        Effect.forEach(requests, (request) =>
          Request.completeEffect(request, Effect.fail(error))
        )
      )
    )
)

// SendEmailがバッチ処理可能であると仮定し、バッチリゾルバを作成します。
export const SendEmailResolver = RequestResolver.makeBatched(
  (requests: ReadonlyArray<Requests.SendEmail>) =>
    Effect.tryPromise({
      try: () =>
        fetch("https://api.example.demo/sendEmailBatch", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            emails: requests.map(({ address, text }) => ({ address, text }))
          })
        }).then((res) => res.json() as Promise<void>),
      catch: () => new Model.SendEmailError()
    }).pipe(
      Effect.andThen(
        Effect.forEach(requests, (request) =>
          Request.completeEffect(request, Effect.void)
        )
      ),
      Effect.catchAll((error) =>
        Effect.forEach(requests, (request) =>
          Request.completeEffect(request, Effect.fail(error))
        )
      )
    )
)
```

```ts filename="Resolvers.ts" twoslash
// @filename: Model.ts
// @include: Model

// @filename: API.ts
// @include: API

// @filename: Requests.ts
// @include: Requests

// @filename: Resolvers.ts
// ---cut---
// @include: Resolvers
```

<Info>
  リゾルバは他の`Effect`と同様にコンテキストにアクセスすることができ、リゾルバを作成する方法は多数あります。
  詳細については、[RequestResolver](https://effect-ts.github.io/effect/effect/RequestResolver.ts.html)モジュールのリファレンスドキュメントを参照してください。
</Info>

この設定では：

- **GetTodosResolver**は複数のTodoアイテムの取得を処理します。バッチ処理できないと仮定しているため、標準的なリゾルバとして設定されています。
- **GetUserByIdResolver**と**SendEmailResolver**はバッチ処理可能なリゾルバとして設定されています。これらのリクエストをバッチで処理できると仮定し、パフォーマンスを向上させ、APIコール数を削減するための設定です。

### クエリの定義

リゾルバの設定が完了したので、すべての要素を結びつけてクエリを定義する準備が整いました。このステップにより、アプリケーション内でデータ操作を効果的に実行できるようになります。

```twoslash include Queries
import { Effect } from "effect"
import * as Model from "./Model"
import * as Requests from "./Requests"
import * as Resolvers from "./Resolvers"

// すべてのTodoアイテムを取得するクエリを定義
export const getTodos: Effect.Effect<
  Array<Model.Todo>,
  Model.GetTodosError
> = Effect.request(Requests.GetTodos({}), Resolvers.GetTodosResolver)

// IDによってユーザーを取得するクエリを定義
export const getUserById = (id: number) =>
  Effect.request(
    Requests.GetUserById({ id }),
    Resolvers.GetUserByIdResolver
  )

// 特定のアドレスにメールを送信するクエリを定義
export const sendEmail = (address: string, text: string) =>
  Effect.request(
    Requests.SendEmail({ address, text }),
    Resolvers.SendEmailResolver
  )

// getUserByIdとsendEmailを組み合わせて、特定のユーザーにメールを送信
export const sendEmailToUser = (id: number, message: string) =>
  getUserById(id).pipe(
    Effect.andThen((user) => sendEmail(user.email, message))
  )

// getUserByIdを使用してTodoの所有者を取得し、メール通知を送信
export const notifyOwner = (todo: Model.Todo) =>
  getUserById(todo.ownerId).pipe(
    Effect.andThen((user) =>
      sendEmailToUser(user.id, `hey ${user.name} you got a todo!`)
    )
  )
```

```ts filename="Queries.ts" twoslash
// @filename: Model.ts
// @include: Model

// @filename: API.ts
// @include: API

// @filename: Requests.ts
// @include: Requests

// @filename: Resolvers.ts
// @include: Resolvers

// @filename: Queries.ts
// ---cut---
// @include: Queries
```

`Effect.request`関数を使用することで、リゾルバをリクエストモデルと効果的に統合しています。このアプローチにより、各クエリが適切なリゾルバを使用して最適に解決されることが保証されます。

コード構造は以前の例と似ていますが、リゾルバを採用することで、リクエストの処理方法を最適化し、不要なAPIコールを減らすことで、効率性が大幅に向上します。

```ts filename="index.ts" {7} twoslash
// @filename: Model.ts
// @include: Model

// @filename: API.ts
// @include: API

// @filename: Requests.ts
// @include: Requests

// @filename: Resolvers.ts
// @include: Resolvers

// @filename: Queries.ts
// @include: Queries

// @filename: index.ts
// ---cut---
import { Effect } from "effect"
import * as Queries from "./Queries"

const program = Effect.gen(function* () {
  const todos = yield* Queries.getTodos
  yield* Effect.forEach(todos, (todo) => Queries.notifyOwner(todo), {
    batching: true
  })
})
```

最終的なセットアップでは、このプログラムはTodoの数に関係なく、APIに対して**3つ**のクエリのみを実行します。これは、従来のアプローチと鋭く対照的です。従来のアプローチでは、Todoの数を**n**とすると、潜在的に**1 + 2n**個のクエリを実行する可能性がありました。これは、特にデータのやり取りが多いアプリケーションにおいて、効率性の大幅な向上を表しています。

### バッチ処理の無効化

バッチ処理は、次のように `Effect.withRequestBatching` ユーティリティを使用してローカルに無効にすることができます：

```ts filename="index.ts" {9} twoslash
// @filename: Model.ts
// @include: Model

// @filename: API.ts
// @include: API

// @filename: Requests.ts
// @include: Requests

// @filename: Resolvers.ts
// @include: Resolvers

// @filename: Queries.ts
// @include: Queries

// @filename: index.ts
// ---cut---
import { Effect } from "effect"
import * as Queries from "./Queries"

const program = Effect.gen(function* () {
  const todos = yield* Queries.getTodos
  yield* Effect.forEach(todos, (todo) => Queries.notifyOwner(todo), {
    concurrency: "unbounded"
  })
}).pipe(Effect.withRequestBatching(false))
```

### コンテキストを持つリゾルバー

複雑なアプリケーションでは、リゾルバーがリクエストを効果的に処理するために、共有サービスや設定にアクセスする必要がしばしばあります。しかし、必要なコンテキストを提供しながらバッチ処理の能力を維持することは課題となる場合があります。ここでは、バッチ処理の能力を損なわないようにリゾルバーでコンテキストを管理する方法を探ります。

リクエストリゾルバーを作成する際、コンテキストを慎重に管理することが重要です。リゾルバーに過剰なコンテキストを提供したり、様々なサービスを提供したりすると、バッチ処理に適さなくなる可能性があります。このような問題を防ぐために、`Effect.request`で使用されるリゾルバーのコンテキストは明示的に`never`に設定されています。これにより、開発者はリゾルバー内でコンテキストがどのようにアクセスされ、使用されるかを明確に定義する必要があります。

以下の例では、リゾルバーがAPIコールを実行するために使用できるHTTPサービスをセットアップします：

```twoslash include ResolversWithContext
import { Effect, Context, RequestResolver } from "effect"
import * as Model from "./Model"
import * as Requests from "./Requests"

export class HttpService extends Context.Tag("HttpService")<
  HttpService,
  { fetch: typeof fetch }
>() {}

export const GetTodosResolver =
  // 以前と同じように通常のリゾルバーを作成します
  RequestResolver.fromEffect((request: Requests.GetTodos) =>
    Effect.andThen(HttpService, (http) =>
      Effect.tryPromise({
        try: () =>
          http
            .fetch("https://api.example.demo/todos")
            .then((res) => res.json() as Promise<Array<Model.Todo>>),
        catch: () => new Model.GetTodosError()
      })
    )
  ).pipe(
    // リゾルバーがアクセスできるタグをリストします
    RequestResolver.contextFromServices(HttpService)
  )
```

```ts filename="ResolversWithContext.ts" twoslash
// @filename: Model.ts
// @include: Model

// @filename: API.ts
// @include: API

// @filename: Requests.ts
// @include: Requests

// @filename: ResolversWithContext.ts
// ---cut---
// @include: ResolversWithContext
```

これで、`GetTodosResolver`の型がもはや`RequestResolver`ではなく、以下のようになっていることがわかります：

```ts
Effect<RequestResolver<GetTodos, never>, never, HttpService>
```

これは`HttpService`にアクセスし、最小限のコンテキストを使用する準備ができた合成リゾルバーを返す`Effect`です。

このような`Effect`を持つと、クエリ定義で直接使用できます：

```ts filename="QueriesWithContext.ts" twoslash
// @filename: Model.ts
// @include: Model

// @filename: API.ts
// @include: API

// @filename: Requests.ts
// @include: Requests

// @filename: ResolversWithContext.ts
// @include: ResolversWithContext

// @filename: QueriesWithContext.ts
// ---cut---
import { Effect } from "effect"
import * as Model from "./Model"
import * as Requests from "./Requests"
import * as ResolversWithContext from "./ResolversWithContext"

export const getTodos = Effect.request(
  Requests.GetTodos({}),
  ResolversWithContext.GetTodosResolver
)
```

Effectが正しく`HttpService`の提供を要求していることがわかります。

あるいは、レイヤーの一部として`RequestResolver`を作成し、構築時のコンテキストに直接アクセスしたり、クロージャーを作成したりすることもできます。

例えば：

```ts filename="QueriesFromLayers.ts" twoslash
// @filename: Model.ts
// @include: Model

// @filename: API.ts
// @include: API

// @filename: Requests.ts
// @include: Requests

// @filename: ResolversWithContext.ts
// @include: ResolversWithContext

// @filename: QueriesFromLayers.ts
// ---cut---
import { Effect, Context, Layer, RequestResolver } from "effect"
import * as API from "./API"
import * as Model from "./Model"
import * as Requests from "./Requests"
import * as ResolversWithContext from "./ResolversWithContext"

export class TodosService extends Context.Tag("TodosService")<
  TodosService,
  {
    getTodos: Effect.Effect<Array<Model.Todo>, Model.GetTodosError>
  }
>() {}

export const TodosServiceLive = Layer.effect(
  TodosService,
  Effect.gen(function* () {
    const http = yield* ResolversWithContext.HttpService
    const resolver = RequestResolver.fromEffect(
      (request: Requests.GetTodos) =>
        Effect.tryPromise<Array<Model.Todo>, Model.GetTodosError>({
          try: () =>
            http
              .fetch("https://api.example.demo/todos")
              .then((res) => res.json()),
          catch: () => new Model.GetTodosError()
        })
    )
    return {
      getTodos: Effect.request(Requests.GetTodos({}), resolver)
    }
  })
)

export const getTodos: Effect.Effect<
  Array<Model.Todo>,
  Model.GetTodosError,
  TodosService
> = Effect.andThen(TodosService, (service) => service.getTodos)
```

これは、レイヤーがサービスを結合する自然なプリミティブであることを考えると、ほとんどの場合に最適な方法でしょう。

## キャッシング

リクエストのバッチ処理を大幅に最適化しましたが、アプリケーションの効率をさらに向上させる別の領域があります：キャッシングです。キャッシングがなければ、最適化されたバッチ処理があっても、同じリクエストが複数回実行され、不必要なデータ取得につながる可能性があります。

Effectライブラリでは、キャッシングは組み込みのユーティリティを通じて処理され、リクエストを一時的に保存することで、変更されていないデータを再取得する必要がなくなります。この機能は、特に頻繁に類似のリクエストを行うアプリケーションにおいて、サーバーとネットワークの両方の負荷を軽減するために重要です。

以下は、`getUserById`クエリにキャッシングを実装する方法です：

```ts {9} filename="Queries.ts" twoslash
// @filename: Model.ts
// @include: Model

// @filename: API.ts
// @include: API

// @filename: Requests.ts
// @include: Requests

// @filename: Resolvers.ts
// @include: Resolvers

// @filename: Queries.ts
// ---cut---
import { Effect } from "effect"
import * as Requests from "./Requests"
import * as Resolvers from "./Resolvers"

export const getUserById = (id: number) =>
  Effect.request(
    Requests.GetUserById({ id }),
    Resolvers.GetUserByIdResolver
  ).pipe(Effect.withRequestCaching(true))
```

## Final Program

Assuming you've wired everything up correctly:

```ts filename="index.ts" twoslash
// @filename: Model.ts
// @include: Model

// @filename: API.ts
// @include: API

// @filename: Requests.ts
// @include: Requests

// @filename: Resolvers.ts
// @include: Resolvers

// @filename: Queries.ts
// @include: Queries

// @filename: index.ts
// ---cut---
import { Effect, Schedule } from "effect"
import * as Queries from "./Queries"

const program = Effect.gen(function* () {
  const todos = yield* Queries.getTodos
  yield* Effect.forEach(todos, (todo) => Queries.notifyOwner(todo), {
    concurrency: "unbounded"
  })
}).pipe(Effect.repeat(Schedule.fixed("10 seconds")))
```

このプログラムでは、`getTodos` 操作が各ユーザーのtodosを取得します。その後、`Effect.forEach` 関数を使用して、通知が完了するのを待たずに各todoの所有者に通知します。

`repeat` 関数は操作の全体のチェーンに適用され、固定スケジュールを使用してプログラムが10秒ごとに繰り返されることを保証します。つまり、todosの取得と通知の送信を含む全プロセスが10秒間隔で繰り返し実行されます。

このプログラムには、1分間に同じ `GetUserById` 操作が複数回実行されるのを防ぐキャッシュメカニズムが組み込まれています。このデフォルトのキャッシュ動作により、プログラムの実行が最適化され、ユーザーデータを取得するための不要なリクエストが減少します。

さらに、プログラムはバッチでメールを送信するように設計されており、効率的な処理とリソースのより良い利用を可能にします。

## リクエストキャッシュのカスタマイズ

実際のアプリケーションでは、効果的なキャッシュ戦略により、冗長なデータ取得を減らすことで、パフォーマンスを大幅に向上させることができます。Effectライブラリは、アプリケーションの特定の部分に合わせたり、グローバルに適用したりできる柔軟なキャッシュメカニズムを提供しています。

アプリケーションの異なる部分で、ユニークなキャッシュ要件が必要なシナリオがあるかもしれません。一部はローカライズされたキャッシュの恩恵を受け、他の部分はグローバルキャッシュのセットアップが必要かもしれません。これらの多様なニーズを満たすためにカスタムキャッシュを設定する方法を探ってみましょう。

### カスタムキャッシュの作成

以下は、カスタムキャッシュを作成し、アプリケーションの一部に適用する方法です。この例では、10秒ごとにタスクを繰り返し、容量やTTL（Time-to-Live）などの特定のパラメータを持つリクエストをキャッシュするキャッシュのセットアップを示しています。

```ts filename="index.ts" twoslash
// @filename: Model.ts
// @include: Model

// @filename: API.ts
// @include: API

// @filename: Requests.ts
// @include: Requests

// @filename: Resolvers.ts
// @include: Resolvers

// @filename: Queries.ts
// @include: Queries

// @filename: index.ts
// ---cut---
import { Effect, Schedule, Layer, Request } from "effect"
import * as Queries from "./Queries"

const program = Effect.gen(function* () {
  const todos = yield* Queries.getTodos
  yield* Effect.forEach(todos, (todo) => Queries.notifyOwner(todo), {
    concurrency: "unbounded"
  })
}).pipe(
  Effect.repeat(Schedule.fixed("10 seconds")),
  Effect.provide(
    Layer.setRequestCache(
      Request.makeCache({ capacity: 256, timeToLive: "60 minutes" })
    )
  )
)
```

### キャッシュの直接適用

`Request.makeCache`を使用してキャッシュを構築し、`Effect.withRequestCache`を使用して特定のプログラムに直接適用することもできます。この方法により、指定されたプログラムから発生するすべてのリクエストが、キャッシュが有効になっている場合、カスタムキャッシュを通じて管理されることが保証されます。
