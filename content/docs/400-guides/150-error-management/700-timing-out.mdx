---
title: タイムアウト
excerpt: `Effect.timeout`を使用して操作に時間制限を設定する方法を学びます。タスクが指定された時間内に完了する必要があるシナリオの処理方法を発見します。タイムアウトが発生したときの動作をカスタマイズするための`timeoutTo`、`timeoutFail`、および`timeoutFailCause`のようなバリエーションを探求し、時間に敏感な操作を管理する際の制御と柔軟性を向上させます。
bottomNavigation: pagination
---

プログラミングの世界では、完了までに時間がかかるタスクをよく扱います。
時には、タスクが完了するまでどれだけ待つかに制限を設けたいことがあります。
ここで`Effect.timeout`関数が役立ちます。
この関数を使用すると、操作に時間制約を設けることができ、無期限に実行されないようにすることができます。

## Basic Usage

### timeout

`Effect.timeout`関数は[Duration](../../other/data-types/duration)パラメータを使用して、操作に時間制限を設定します。操作がこの制限を超えると、タイムアウトが発生したことを示す`TimeoutException`がトリガーされます。

以下は、`Effect.timeout`を操作に適用する基本的な例です：

```ts twoslash
import { Effect } from "effect"

const myEffect = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

// このエフェクトをラップし、最大許容時間を3秒に設定します
const timedEffect = myEffect.pipe(Effect.timeout("3 seconds"))

// 出力はタスクが正常に完了することを示します
// タイムアウト時間内に収まっているため
Effect.runPromiseExit(timedEffect).then(console.log)
/*
出力:
Start processing...
Processing complete.
{ _id: 'Exit', _tag: 'Success', value: 'Result' }
*/
```

上記の例では、操作が指定された期間内に完了するため、結果が正常に返されます。

操作が指定された期間よりも長くかかる場合、`TimeoutException`が発生します：

```ts twoslash
import { Effect } from "effect"

const myEffect = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds")
  console.log("Processing complete.")
  return "Result"
})
// ---cut---
const timedEffect = myEffect.pipe(Effect.timeout("1 second"))

Effect.runPromiseExit(timedEffect).then(console.log)
/*
出力:
Start processing...
{
  _id: 'Exit',
  _tag: 'Failure',
  cause: { _id: 'Cause', _tag: 'Fail', failure: { _tag: 'TimeoutException' } }
}
*/
```

### timeoutOption

タイムアウトを通常の結果として扱いたい場合は、`Effect.timeout`の代わりに`Effect.timeoutOption`を使用できます。

```ts twoslash
import { Effect } from "effect"

const myEffect = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds")
  console.log("Processing complete.")
  return "Result"
})

const timedOutEffect = Effect.all([
  myEffect.pipe(Effect.timeoutOption("3 seconds")),
  myEffect.pipe(Effect.timeoutOption("1 second"))
])

Effect.runPromise(timedOutEffect).then(console.log)
/*
出力:
Start processing...
Processing complete.
Start processing...
[
  { _id: 'Option', _tag: 'Some', value: 'Result' },
  { _id: 'Option', _tag: 'None' }
]
*/
```

この例では、最初のエフェクトは指定された期間内に完了しますが、2番目のエフェクトはタイムアウトします。
タイムアウトしたエフェクトの結果は[Option](../../other/data-types/option)型でラップされ、タイムアウトを通常の結果として扱うことができます。

## タイムアウトの処理

操作が指定された期間内に完了しない場合、`Effect.timeout`の動作は操作が中断不可能かどうかによって異なります。

<Info>
  **中断不可能な**エフェクトは、一度開始されると、タイムアウトメカニズムによって直接実行中に停止することができません。
  これは、システムを不整合な状態にしないために、エフェクト内の操作が完了まで実行される必要があるためかもしれません。
</Info>

1. **中断可能な操作**: 操作が中断可能な場合、タイムアウトのしきい値に達すると即座に終了し、`TimeoutException`が発生します。

   ```ts twoslash
   import { Effect } from "effect"

   const myEffect = Effect.gen(function* () {
     console.log("Start processing...")
     yield* Effect.sleep("2 seconds") // Simulates a delay in processing
     console.log("Processing complete.")
     return "Result"
   })

   const timedEffect = myEffect.pipe(Effect.timeout("1 second"))

   Effect.runPromiseExit(timedEffect).then(console.log)
   /*
   出力:
   Start processing...
   {
     _id: 'Exit',
     _tag: 'Failure',
     cause: { _id: 'Cause', _tag: 'Fail', failure: { _tag: 'TimeoutException' } }
   }
   */
   ```

2. **中断不可能な操作**: 操作が中断不可能な場合、`TimeoutException`が評価される前に完了まで続行されます。

   ```ts twoslash
   import { Effect } from "effect"

   const myEffect = Effect.gen(function* () {
     console.log("Start processing...")
     yield* Effect.sleep("2 seconds") // Simulates a delay in processing
     console.log("Processing complete.")
     return "Result"
   })

   const timedEffect = myEffect.pipe(
     Effect.uninterruptible,
     Effect.timeout("1 second")
   )

   // タスクが中断不可能であるため、タスクが完了した後にTimeoutExceptionを出力します
   Effect.runPromiseExit(timedEffect).then(console.log)
   /*
   出力:
   Start processing...
   Processing complete.
   {
     _id: 'Exit',
     _tag: 'Failure',
     cause: { _id: 'Cause', _tag: 'Fail', failure: { _tag: 'TimeoutException' } }
   }
   */
   ```

## タイムアウト時の切断

`Effect.disconnect`関数は、特に中断不可能なエフェクトを扱う際に、タイムアウトをより細かく処理するために使用されます。

これにより、中断不可能なエフェクトがバックグラウンドで操作を完了できるようになり、一方でメインの制御フローはタイムアウトが発生したかのように進行します。

以下が区別点です：

- **Effect.disconnectを使用しない場合**：

  - 中断不可能なエフェクトはタイムアウトを無視し、完了するまで実行を続け、その後タイムアウトエラーが評価されます。
  - これにより、システムがエフェクトの完了を待つ必要があるため、タイムアウト状態の認識に遅延が生じる可能性があります。

- **Effect.disconnectを使用する場合**：

  - 中断不可能なエフェクトはメインの制御フローとは独立して、バックグラウンドで継続することが許可されます。
  - メインの制御フローは即座にタイムアウトを認識し、エフェクトの完了を待つことなく、タイムアウトエラーまたは代替ロジックで進行します。
  - この方法は、エフェクトの操作が中断不可能とマークされているにもかかわらず、プログラムの継続をブロックする必要がない場合に特に有用です。

**例**

長時間実行されるデータ処理タスクが開始され、データ処理に時間がかかりすぎても、システムの応答性を確保したい場合を考えてみましょう：

```ts twoslash
import { Effect } from "effect"

const longRunningTask = Effect.gen(function* () {
  console.log("Start heavy processing...")
  yield* Effect.sleep("5 seconds") // 長時間のプロセスをシミュレート
  console.log("Heavy processing done.")
  return "Data processed"
})

const timedEffect = longRunningTask.pipe(
  Effect.uninterruptible,
  Effect.disconnect, // タイムアウトした場合でもタスクが独立して完了することを許可します
  Effect.timeout("1 second")
)

Effect.runPromiseExit(timedEffect).then(console.log)
/*
出力:
Start heavy processing...
{
  _id: 'Exit',
  _tag: 'Failure',
  cause: { _id: 'Cause', _tag: 'Fail', failure: { _tag: 'TimeoutException' } }
}
Heavy processing done.
*/
```

## タイムアウト動作のカスタマイズ

基本的な`Effect.timeout`関数に加えて、タイムアウトが発生したときの動作をカスタマイズできるバリエーションがあります。

### timeoutFail

`Effect.timeoutFail`関数を使用すると、タイムアウトが発生したときに特定のエラーを生成できます：

```ts twoslash
import { Effect } from "effect"

const myEffect = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // 処理の遅延をシミュレート
  console.log("Processing complete.")
  return "Result"
})

class MyTimeoutError {
  readonly _tag = "MyTimeoutError"
}

const program = myEffect.pipe(
  Effect.timeoutFail({
    duration: "1 second",
    onTimeout: () => new MyTimeoutError()
  })
)

Effect.runPromiseExit(program).then(console.log)
/*
出力:
Start processing...
{
  _id: 'Exit',
  _tag: 'Failure',
  cause: {
    _id: 'Cause',
    _tag: 'Fail',
    failure: MyTimeoutError { _tag: 'MyTimeoutError' }
  }
}
*/
```

### timeoutFailCause

`Effect.timeoutFailCause`関数を使用すると、タイムアウトが発生したときに特定の欠陥を生成できます。
これは、コード内でタイムアウトを例外的なケースとして処理する必要がある場合に便利です：

```ts twoslash
import { Effect, Cause } from "effect"

const myEffect = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // 処理の遅延をシミュレート
  console.log("Processing complete.")
  return "Result"
})

const program = myEffect.pipe(
  Effect.timeoutFailCause({
    duration: "1 second",
    onTimeout: () => Cause.die("Timed out!")
  })
)

Effect.runPromiseExit(program).then(console.log)
/*
出力:
Start processing...
{
  _id: 'Exit',
  _tag: 'Failure',
  cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }
}
*/
```

### timeoutTo

`Effect.timeoutTo`関数は`Effect.timeout`に似ていますが、最終的な結果の型をより細かく制御できます。
成功した操作とタイムアウトした操作の両方に対して、代替の結果を定義することができます：

```ts twoslash
import { Effect, Either } from "effect"

const myEffect = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // 処理の遅延をシミュレート
  console.log("Processing complete.")
  return "Result"
})

const program = myEffect.pipe(
  Effect.timeoutTo({
    duration: "1 second",
    // Eitherを返しましょう
    onSuccess: (result): Either.Either<string, string> =>
      Either.right(result),
    onTimeout: (): Either.Either<string, string> => Either.left("Timed out!")
  })
)

Effect.runPromise(program).then(console.log)
/*
出力:
Start processing...
{
  _id: "Either",
  _tag: "Left",
  left: "Timed out!"
}
*/
```
