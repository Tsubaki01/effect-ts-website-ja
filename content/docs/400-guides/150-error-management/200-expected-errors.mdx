---
title: 予期されたエラー
excerpt: Effectが予期されたエラーをどのように表現し管理するかを探ります。エラーインスタンスの作成、型レベルでのエラー追跡、Effectプログラムのショートサーキット動作について学びます。エラーをキャッチして回復する技術を発見し、Effectの強力なコンビネータを使用したエラーハンドリング戦略についての洞察を得ます。
bottomNavigation: pagination
---

このガイドでは以下を学びます：

- Effectが予期されたエラーをどのように表現するか
- Effectが提供する堅牢で包括的なエラーマネジメントツール

ガイド[Effectの作成](../essentials/creating-effects)で見たように、`fail`コンストラクタを使用してエラーを表すEffectを作成できます：

```ts twoslash
import { Effect } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

const program = Effect.fail(new HttpError())
```

<Info>
  上記の`HttpError`型を表現するためにクラスを使用していますが、
  これはエラータイプとフリーコンストラクタの両方にアクセスするためです。
  しかし、エラータイプをモデル化するために好きなものを使用することができます。
</Info>

この例では、エラーの識別子としてreadonlyの`_tag`フィールドを追加していることに注意してください：

```ts {1}
class HttpError {
  readonly _tag = "HttpError"
}
```

<Idea>
  `_tag`のような識別フィールドを追加することは、エラーハンドリング中に異なる種類のエラーを区別するのに役立ちます。
  また、TypeScriptが型を統一するのを防ぎ、各エラーがその識別値に基づいて個別に扱われることを保証します。
</Idea>

予期されたエラーは、`Effect`データ型の「Error」チャネルで**型レベルで追跡されます**。

`program`の型から、`HttpError`型のエラーで失敗する可能性があることが明らかです：

```ts
Effect<never, HttpError, never>
```

## エラーの追跡

次のプログラムは、エラーが自動的に追跡される方法を示す例です：

<Tabs items={["Using Effect.gen", "Using pipe"]}>
<Tab>

```twoslash include error-tracking
import { Effect, Random } from "effect"

export class HttpError {
  readonly _tag = "HttpError"
}

export class ValidationError {
  readonly _tag = "ValidationError"
}

export const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next

  const httpResult =
    n1 > 0.5 ? "yay!" : yield* Effect.fail(new HttpError())
  const validationResult =
    n2 > 0.5 ? "yay!" : yield* Effect.fail(new ValidationError())

  return httpResult + validationResult
})
```

```ts filename="error-tracking.ts" twoslash
// @include: error-tracking

Effect.runPromise(program).then(console.log, console.error)
```

上記のプログラムでは、`httpResult`と`validationResult`という2つの値を計算しています。それぞれがエラーの潜在的な原因を表しています。

</Tab>
<Tab>

```ts filename="error-tracking.ts" twoslash
import { Effect, Random } from "effect"

export class HttpError {
  readonly _tag = "HttpError"
}

export class ValidationError {
  readonly _tag = "ValidationError"
}

const httpResult = Random.next.pipe(
  Effect.andThen((n1) =>
    n1 > 0.5 ? Effect.succeed("yay!") : Effect.fail(new HttpError())
  )
)

const validationResult = Random.next.pipe(
  Effect.andThen((n2) =>
    n2 > 0.5 ? Effect.succeed("yay!") : Effect.fail(new ValidationError())
  )
)

export const program = Effect.all([httpResult, validationResult]).pipe(
  Effect.andThen(([http, validation]) => http + validation)
)
```

上記のプログラムでは、`httpResult`と`validationResult`という2つの操作があり、それぞれが潜在的なエラーの原因を表しています。
これらの操作は、Effectライブラリの`Effect.all(effects)`関数を使用して組み合わされており、これによってそれらを順序付けて実行することができます。

</Tab>
</Tabs>

Effectは、プログラムの実行中に発生する可能性のあるエラーを自動的に追跡します。
この場合、`HttpError`と`ValidationError`が可能なエラータイプとして存在します。
`program`のエラーチャンネルは以下のように指定されます：

```ts
Effect<string, HttpError | ValidationError, never>
```

これは、`HttpError`または`ValidationError`のいずれかで潜在的に失敗する可能性があることを示しています。

## ショートサーキット

`Effect.gen`、`Effect.map`、`Effect.flatMap`、`Effect.andThen`、`Effect.all`のようなAPIを使用する際には、これらがエラーをどのように処理するかを理解することが重要です。
これらのAPIは、**最初のエラー**に遭遇した時点で**実行をショートサーキット**するように設計されています。

開発者として、これはどういう意味でしょうか？例えば、一連の操作やエフェクトのコレクションを順番に実行する場合を考えてみましょう。これらのエフェクトの実行中にエラーが発生した場合、残りの計算はスキップされ、そのエラーが最終結果に伝播されます。

簡単に言えば、ショートサーキットの動作は、プログラムのどのステップで問題が発生しても、不要な計算を実行する時間を無駄にしないことを保証します。代わりに、すぐに停止してエラーを返し、何が問題だったかを知らせてくれます。

<Tabs items={["Using Effect.gen", "Using pipe"]}>
<Tab>

```ts twoslash
import { Effect, Console } from "effect"

// 3つの異なるタスクを表すエフェクトを定義します。
const task1 = Console.log("Executing task1...")
const task2 = Effect.fail("Something went wrong!")
const task3 = Console.log("Executing task3...")

// 3つのタスクを順番に実行するように構成します。
// もし1つのタスクが失敗した場合、後続のタスクは実行されません。
const program = Effect.gen(function* () {
  yield* task1
  yield* task2 // task1の後にtask2が実行されますが、エラーで失敗します
  yield* task3 // 前の計算が失敗するため、この計算は実行されません
})

Effect.runPromiseExit(program).then(console.log)
/*
出力:
Executing task1...
{
  _id: 'Exit',
  _tag: 'Failure',
  cause: { _id: 'Cause', _tag: 'Fail', failure: 'Something went wrong!' }
}
*/
```

</Tab>
<Tab>

```ts twoslash
import { Effect, Console } from "effect"

// 3つの異なるタスクを表すエフェクトを定義します。
const task1 = Console.log("Executing task1...")
const task2 = Effect.fail("Something went wrong!")
const task3 = Console.log("Executing task3...")

// 3つのタスクを`Effect.andThen`を使って順番に実行するように構成します。
// `Effect.andThen`関数を使うことで、エフェクトを連鎖させることができます。
// もし1つのタスクが失敗した場合、後続のタスクは実行されません。
const program = task1.pipe(
  Effect.andThen(task2), // task1の後にtask2が実行されますが、エラーで失敗します
  Effect.andThen(task3) // 前の計算が失敗するため、この計算は実行されません
)

Effect.runPromiseExit(program).then(console.log)
/*
出力:
Executing task1...
{
  _id: 'Exit',
  _tag: 'Failure',
  cause: { _id: 'Cause', _tag: 'Fail', failure: 'Something went wrong!' }
}
*/
```

</Tab>
</Tabs>

このコードスニペットは、エラーが発生したときのショートサーキット動作を示しています。
各操作は前の操作が成功することに依存しています。
もしエラーが発生した場合、実行はショートサーキットされ、エラーが伝播されます。
この具体的な例では、`task2`でエラーが発生するため、`task3`は実行されません。

## すべてのエラーをキャッチする

### either

`Effect.either` 関数は、`Effect<A, E, R>` を、[Either](../../other/data-types/either) データ型内に潜在的な失敗と成功の両方をカプセル化したエフェクトに変換します：

```ts
Effect<A, E, R> -> Effect<Either<A, E>, never, R>
```

結果として得られるエフェクトは失敗することができません。なぜなら、潜在的な失敗が`Either`の`Left`型の中で表現されているからです。
返される`Effect`のエラー型は`never`と指定されており、このエフェクトが失敗しないように構造化されていることを確認しています。

`Either`を生成することで、ジェネレーター関数内で失敗と成功の両方のケースを処理するために、この型に対して「パターンマッチング」を行う能力を得ることができます。

```ts twoslash
// @filename: error-tracking.ts
// @include: error-tracking

// @filename: index.ts
// ---cut---
import { Effect, Either } from "effect"
import { program } from "./error-tracking"

const recovered = Effect.gen(function* () {
  const failureOrSuccess = yield* Effect.either(program)
  if (Either.isLeft(failureOrSuccess)) {
    // 失敗の場合: `left` プロパティからエラーを抽出できます
    const error = failureOrSuccess.left
    return `Recovering from ${error._tag}`
  } else {
    // 成功の場合: `right` プロパティから値を抽出できます
    return failureOrSuccess.right
  }
})
```

`Either.match` 関数を使用することで、エラーと成功の値を処理するための2つのコールバック関数を直接受け取るため、コードをより簡潔にすることができます。

```ts twoslash
// @filename: error-tracking.ts
// @include: error-tracking

// @filename: index.ts
// ---cut---
import { Effect, Either } from "effect"
import { program } from "./error-tracking"

const recovered = Effect.gen(function* () {
  const failureOrSuccess = yield* Effect.either(program)
  return Either.match(failureOrSuccess, {
    onLeft: (error) => `Recovering from ${error._tag}`,
    onRight: (value) => value // 成功の場合は何もしない
  })
})
```

### catchAll

`Effect.catchAll` 関数は、プログラム内で発生するあらゆるエラーをキャッチし、フォールバックを提供することができます。

```ts {5} twoslash
// @filename: error-tracking.ts
// @include: error-tracking

// @filename: index.ts
// ---cut---
import { Effect } from "effect"
import { program } from "./error-tracking"

const recovered = program.pipe(
  Effect.catchAll((error) => Effect.succeed(`Recovering from ${error._tag}`))
)
```

エラーチャンネルの型が `never` に変わったことが確認できます。これは、すべてのエラーが処理されたことを示しています。

## 特定のエラーをキャッチする

`HttpError` のような特定のエラーを処理したいとします。

```ts {8-10} twoslash
// @filename: error-tracking.ts
// @include: error-tracking

// @filename: index.ts
// ---cut---
import { Effect, Either } from "effect"
import { program } from "./error-tracking"

const recovered = Effect.gen(function* () {
  const failureOrSuccess = yield* Effect.either(program)
  if (Either.isLeft(failureOrSuccess)) {
    const error = failureOrSuccess.left
    if (error._tag === "HttpError") {
      return "Recovering from HttpError"
    }
    return yield* Effect.fail(error)
  } else {
    return failureOrSuccess.right
  }
})
```

プログラムのエラーチャンネルの型が `ValidationError` のみを表示するように変更されたことが確認できます。
これは、`HttpError` が処理されたことを示しています。

`ValidationError` も処理したい場合は、コードに別のケースを簡単に追加できます：

```ts {11} twoslash
// @filename: error-tracking.ts
// @include: error-tracking

// @filename: index.ts
// ---cut---
import { Effect, Either } from "effect"
import { program } from "./error-tracking"

const recovered = Effect.gen(function* () {
  const failureOrSuccess = yield* Effect.either(program)
  if (Either.isLeft(failureOrSuccess)) {
    const error = failureOrSuccess.left
    if (error._tag === "HttpError") {
      return "Recovering from HttpError"
    } else {
      return "Recovering from ValidationError"
    }
  } else {
    return failureOrSuccess.right
  }
})
```

プログラムのエラーチャンネルの型が `never` に変わったことが確認できます。これは、すべてのエラーが処理されたことを示しています。

### catchSome

特定の種類のエラーのみをキャッチして回復を試みたい場合は、`Effect.catchSome` 関数を使用できます。

```ts twoslash
// @filename: error-tracking.ts
// @include: error-tracking

// @filename: index.ts
// ---cut---
import { Effect, Option } from "effect"
import { program } from "./error-tracking"

const recovered = program.pipe(
  Effect.catchSome((error) => {
    if (error._tag === "HttpError") {
      return Option.some(Effect.succeed("Recovering from HttpError"))
    }
    return Option.none()
  })
)
```

上記のコードでは、`Effect.catchSome` はエラー (`error`) を調べて回復を試みるかどうかを決定する関数を受け取ります。エラーが特定の条件に一致する場合、`Option.some(effect)` を返すことで回復を試みることができます。回復が不可能な場合は、単に `Option.none()` を返すことができます。

`Effect.catchSome`は特定のエラーをキャッチすることができますが、**エラーの型自体を変更しない**ことに注意することが重要です。したがって、結果として得られるエフェクト（この場合は`recovered`）は、元のエフェクトと同じエラー型（`HttpError | ValidationError`）を持ち続けます。

### catchIf

`Effect.catchSome` と同様に、`Effect.catchIf` 関数は、述語に基づいて特定のエラーから回復することを可能にします：

```ts twoslash
// @filename: error-tracking.ts
// @include: error-tracking

// @filename: index.ts
// ---cut---
import { Effect } from "effect"
import { program } from "./error-tracking"

const recovered = program.pipe(
  Effect.catchIf(
    (error) => error._tag === "HttpError",
    () => Effect.succeed("Recovering from HttpError")
  )
)
```

TypeScriptのバージョン5.5未満では、`Effect.catchIf`は特定のエラーをキャッチできますが、エラーの型自体を**変更しない**ことに注意することが重要です。そのため、結果として得られるエフェクト（この場合は`recovered`）は、元のエフェクトと同じエラー型（`HttpError | ValidationError`）を持ち続けます。TypeScriptのバージョン5.5以降では、改善された型の絞り込みにより、結果のエラー型は`ValidationError`と推論されます。

TypeScriptのバージョン5.5未満では、述語の代わりに[ユーザー定義型ガード](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)を提供すると、結果のエラー型が刈り込まれ、`Effect<string, ValidationError, never>`が返されます：

```ts {6} twoslash
// @filename: error-tracking.ts
// @include: error-tracking

// @filename: index.ts
// ---cut---
import { Effect } from "effect"
import { program, HttpError } from "./error-tracking"

const recovered = program.pipe(
  Effect.catchIf(
    (error): error is HttpError => error._tag === "HttpError",
    () => Effect.succeed("Recovering from HttpError")
  )
)
```

### catchTag

プログラムのエラーがすべて識別子として機能する `_tag` フィールドでタグ付けされている場合、`Effect.catchTag` 関数を使用して特定のエラーを正確にキャッチして処理することができます。

```ts {5-7} twoslash
// @filename: error-tracking.ts
// @include: error-tracking

// @filename: index.ts
// ---cut---
import { Effect } from "effect"
import { program } from "./error-tracking"

const recovered = program.pipe(
  Effect.catchTag("HttpError", (_HttpError) =>
    Effect.succeed("Recovering from HttpError")
  )
)
```

上記の例では、`Effect.catchTag`関数を使用して`HttpError`を特定的に処理することができます。
プログラムの実行中に`HttpError`が発生した場合、提供されたエラーハンドラー関数が呼び出され、
プログラムはハンドラー内で指定されたリカバリーロジックで進行します。

プログラムのエラーチャンネルの型が`ValidationError`のみを表示するように変更されたことが観察できます。
これは`HttpError`が処理されたことを示しています。

`ValidationError`も処理したい場合は、単に別の`catchTag`を追加するだけです：

```ts {8-10} twoslash
// @filename: error-tracking.ts
// @include: error-tracking

// @filename: index.ts
// ---cut---
import { Effect } from "effect"
import { program } from "./error-tracking"

const recovered = program.pipe(
  Effect.catchTag("HttpError", (_HttpError) =>
    Effect.succeed("Recovering from HttpError")
  ),
  Effect.catchTag("ValidationError", (_ValidationError) =>
    Effect.succeed("Recovering from ValidationError")
  )
)
```

プログラムのエラーチャンネルの型が `never` に変わったことが観察できます。
これはすべてのエラーが処理されたことを示しています。

<Warning>
  `catchTag` で使用するエラー型には `readonly _tag`
  判別フィールドが必要であることを
  確認することが重要です。このフィールドは特定のエラータグをマッチングし、
  処理するために必要です。
</Warning>

### catchTags

個々のエラータイプを処理するために `Effect.catchTag` 関数を複数回使用する代わりに、
より便利なオプションとして `Effect.catchTags` があります。`Effect.catchTags` を使用すると、
1つのコードブロックで複数のエラーを処理することができます。

```ts {5-8} twoslash
// @filename: error-tracking.ts
// @include: error-tracking

// @filename: index.ts
// ---cut---
import { Effect } from "effect"
import { program } from "./error-tracking"

const recovered = program.pipe(
  Effect.catchTags({
    HttpError: (_HttpError) => Effect.succeed(`Recovering from HttpError`),
    ValidationError: (_ValidationError) =>
      Effect.succeed(`Recovering from ValidationError`)
  })
)
```

上記の例では、個々のエラーを処理するために `Effect.catchTag` を複数回使用する代わりに、`Effect.catchTags` コンビネータを利用しています。
このコンビネータは、各プロパティが特定のエラー `_tag`（この場合は `"HttpError"` と `"ValidationError"`）を表すオブジェクトを受け取り、
対応する値はそのエラーが発生した際に実行されるエラーハンドラ関数となります。

<Warning>
  `Effect.catchTags` で使用するすべてのエラータイプに `readonly _tag`
  判別フィールドがあることを確認することが重要です。
  このフィールドは特定のエラータグをマッチングし、処理するために必要です。
</Warning>
