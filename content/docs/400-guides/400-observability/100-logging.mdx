---
title: ロギング
excerpt: デバッグとモニタリングを強化するためのEffectのロギングの力を探求します。動的なログレベル制御、カスタムロギング出力、細かいロギング、環境ベースのロギング、および追加機能について学びます。log、logDebug、logInfo、logWarning、logError、logFatal、スパンなどの特定のロギングユーティリティについて詳しく説明します。デフォルトのロギングを無効にし、設定からログレベルを読み込む方法を発見します。最後に、ニーズに合わせたカスタムロガーの作成方法を探ります。
bottomNavigation: pagination
---

ロギングはソフトウェア開発において非常に重要な側面であり、特にアプリケーションの動作をデバッグおよびモニタリングする際に重要です。このセクションでは、Effectのロギングユーティリティに深く掘り下げ、`console.log`のような従来の方法に対する利点を探ります。

## 従来のロギングに対する利点

Effectのロギングユーティリティは、`console.log`のような従来のロギング方法に対していくつかの利点を提供します：

1. **動的なログレベル制御**: Effectのロギングを使用すると、ログレベルを動的に変更することができます。これにより、重大度に基づいて表示されるログメッセージを制御できます。たとえば、アプリケーションを警告やエラーのみをログするように構成することができ、これにより本番環境でのノイズを減らすことが非常に役立ちます。

2. **カスタムロギング出力**: Effectのロギングユーティリティを使用すると、ログの処理方法を変更できます。ログメッセージをサービスやファイルなどのさまざまな宛先に送信することができます。[カスタムロガー](#custom-loggers)を使用することで、この柔軟性により、アプリケーションの要件に最適な方法でログを保存および処理できます。

3. **細かいロギング**: Effectは、プログラムの各部分ごとに細かいロギング制御を可能にします。アプリケーションの異なる部分に対して異なるログレベルを設定し、各特定のコンポーネントに対して詳細度を調整できます。これにより、デバッグやトラブルシューティングの際に最も重要な情報に集中することができます。

4. **環境ベースのロギング**: Effectのロギングユーティリティは、デプロイメント環境と組み合わせて詳細なロギング戦略を実現できます。たとえば、開発中は詳細なデバッグのためにトレースレベル以上のすべてをログすることを選択できます。対照的に、本番バージョンではエラーや重大な問題のみをログするように構成し、本番ログのパフォーマンスとノイズへの影響を最小限に抑えることができます。

5. **追加機能**: Effectのロギングユーティリティには、時間の測定、エフェクトごとのログレベルの変更、パフォーマンスモニタリングのためのスパンの統合などの追加機能が備わっています。

それでは、Effectが提供する特定のロギングユーティリティについて詳しく見ていきましょう。

## log

`Effect.log`関数は、デフォルトの`INFO`レベルでログメッセージを出力します。

```ts twoslash
import { Effect } from "effect"

const program = Effect.log("Application started")

Effect.runFork(program)
/*
出力:
timestamp=... level=INFO fiber=#0 message="Application started"
*/
```

デフォルトのロガーを`Effect.log`で使用すると、各ログエントリに以下の重要な詳細が含まれます：

- `timestamp`: ログメッセージが生成された時のタイムスタンプ。
- `level`: メッセージがログされるログレベル。
- `fiber`: プログラムを実行している[ファイバー](../concurrency/fibers)の識別子。
- `message`: ログの内容。複数の項目を含むことができます。
- `span`: （オプション）[スパン](#spans)の継続時間（ミリ秒単位）。

<Info>
  カスタムロギングフレームワークの統合やログフォーマットの調整など、特定のニーズに合わせてロギング設定をカスタマイズする方法については、
  [カスタムロガー](#custom-loggers)のセクションを参照してください。
</Info>

複数のメッセージを同時にログすることができます：

```ts twoslash
import { Effect } from "effect"

const program = Effect.log("message1", "message2", "message3")

Effect.runFork(program)
/*
出力:
timestamp=... level=INFO fiber=#0 message=message1 message=message2 message=message3
*/
```

追加のコンテキストとして、ログに1つ以上の[Cause](../../other/data-types/cause)インスタンスを含めることもできます。
これらは追加の`cause`アノテーションの下で詳細なエラー情報を提供します：

```ts twoslash
import { Effect, Cause } from "effect"

const program = Effect.log(
  "message1",
  "message2",
  Cause.die("Oh no!"),
  Cause.die("Oh uh!")
)

Effect.runFork(program)
/*
出力:
timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause="Error: Oh no!
Error: Oh uh!"
*/
```

## ログレベル

### logDebug

デフォルトでは、`DEBUG` メッセージは表示されません。

しかし、`Logger.withMinimumLogLevel` を使用してデフォルトのロガーを設定し、最小ログレベルを `LogLevel.Debug` に設定することで、これらを有効にすることができます。

以下は、特定のタスク（`task1`）に対して `DEBUG` メッセージを有効にする方法を示す例です：

<Tabs items={["Effect.genを使用", "pipeを使用"]}>
<Tab>

```ts twoslash
import { Effect, Logger, LogLevel } from "effect"

const task1 = Effect.gen(function* () {
  yield* Effect.sleep("2 seconds")
  yield* Effect.logDebug("task1 done")
}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug))

const task2 = Effect.gen(function* () {
  yield* Effect.sleep("1 second")
  yield* Effect.logDebug("task2 done")
})

const program = Effect.gen(function* () {
  yield* Effect.log("start")
  yield* task1
  yield* task2
  yield* Effect.log("done")
})

Effect.runFork(program)
/*
出力:
timestamp=... level=INFO message=start
timestamp=... level=DEBUG message="task1 done" <-- 2 seconds later
timestamp=... level=INFO message=done <-- 1 second later
*/
```

</Tab>
<Tab>

```ts twoslash
import { Effect, Logger, LogLevel } from "effect"

const task1 = Effect.sleep("2 seconds").pipe(
  Effect.andThen(Effect.logDebug("task1 done")),
  Logger.withMinimumLogLevel(LogLevel.Debug)
)

const task2 = Effect.sleep("1 second").pipe(
  Effect.andThen(Effect.logDebug("task2 done"))
)

const program = Effect.log("start").pipe(
  Effect.andThen(task1),
  Effect.andThen(task2),
  Effect.andThen(Effect.log("done"))
)

Effect.runFork(program)
/*
出力:
timestamp=... level=INFO message=start
timestamp=... level=DEBUG message="task1 done" <-- 2 seconds later
timestamp=... level=INFO message=done <-- 1 second later
*/
```

</Tab>
</Tabs>

上記の例では、`Logger.withMinimumLogLevel` 関数を使用して、特に `task1` に対して `DEBUG` メッセージを有効にしています。

`Logger.withMinimumLogLevel(effect, level)` を使用することで、プログラム内の特定のエフェクトに対して異なるログレベルを選択的に有効にする柔軟性が得られます。これにより、ログの詳細レベルを制御し、デバッグやトラブルシューティングのニーズに最も関連する情報に焦点を当てることができます。

### logInfo

デフォルトでは、`INFO` メッセージが出力されます。

<Tabs items={["Effect.genを使用する", "pipeを使用する"]}>
<Tab>

```ts twoslash
import { Effect } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.logInfo("start")
  yield* Effect.sleep("2 seconds")
  yield* Effect.sleep("1 second")
  yield* Effect.logInfo("done")
})

Effect.runFork(program)
/*
出力:
timestamp=... level=INFO message=start
timestamp=... level=INFO message=done <-- 3 seconds later
*/
```

</Tab>
<Tab>

```ts twoslash
import { Effect } from "effect"

const program = Effect.logInfo("start").pipe(
  Effect.andThen(Effect.sleep("2 seconds")),
  Effect.andThen(Effect.sleep("1 second")),
  Effect.andThen(Effect.logInfo("done"))
)

Effect.runFork(program)
/*
出力:
timestamp=... level=INFO message=start
timestamp=... level=INFO message=done <-- 3 seconds later
*/
```

</Tab>
</Tabs>

上記の例では、`Effect.log` 関数を使用して、内容が `"start"` および `"done"` の `INFO` メッセージをログに記録しています。これらのメッセージはプログラムの実行中に出力されます。

### logWarning

デフォルトでは、`WARN` メッセージが出力されます。

<Tabs items={["Effect.genを使用する", "pipeを使用する"]}>
<Tab>

```ts twoslash
import { Effect, Either } from "effect"

const task = Effect.fail("Oh uh!").pipe(Effect.as(2))

const program = Effect.gen(function* () {
  const failureOrSuccess = yield* Effect.either(task)
  if (Either.isLeft(failureOrSuccess)) {
    yield* Effect.logWarning(failureOrSuccess.left)
    return 0
  } else {
    return failureOrSuccess.right
  }
})

Effect.runFork(program)
/*
出力:
timestamp=... level=WARN fiber=#0 message="Oh uh!"
*/
```

</Tab>
<Tab>

```ts twoslash
import { Effect } from "effect"

const task = Effect.fail("Oh uh!").pipe(Effect.as(2))

const program = task.pipe(
  Effect.catchAll((error) => Effect.logWarning(error).pipe(Effect.as(0)))
)

Effect.runFork(program)
/*
出力:
timestamp=... level=WARN fiber=#0 message="Oh uh!"
*/
```

</Tab>
</Tabs>

### logError

デフォルトでは、`ERROR` メッセージが表示されます。

<Tabs items={["Effect.genを使用する", "pipeを使用する"]}>
<Tab>

```ts twoslash
import { Effect, Either } from "effect"

const task = Effect.fail("Oh uh!").pipe(Effect.as(2))

const program = Effect.gen(function* () {
  const failureOrSuccess = yield* Effect.either(task)
  if (Either.isLeft(failureOrSuccess)) {
    yield* Effect.logError(failureOrSuccess.left)
    return 0
  } else {
    return failureOrSuccess.right
  }
})

Effect.runFork(program)
/*
出力:
timestamp=... level=ERROR fiber=#0 message="Oh uh!"
*/
```

</Tab>
<Tab>

```ts twoslash
import { Effect } from "effect"

const task = Effect.fail("Oh uh!").pipe(Effect.as(2))

const program = task.pipe(
  Effect.catchAll((error) => Effect.logError(error).pipe(Effect.as(0)))
)

Effect.runFork(program)
/*
出力:
timestamp=... level=ERROR fiber=#0 message="Oh uh!"
*/
```

</Tab>
</Tabs>

### logFatal

デフォルトでは、`FATAL` メッセージが表示されます。

<Tabs items={["Effect.genを使用する", "pipeを使用する"]}>
<Tab>

```ts twoslash
import { Effect, Either } from "effect"

const task = Effect.fail("Oh uh!").pipe(Effect.as(2))

const program = Effect.gen(function* () {
  const failureOrSuccess = yield* Effect.either(task)
  if (Either.isLeft(failureOrSuccess)) {
    yield* Effect.logFatal(failureOrSuccess.left)
    return 0
  } else {
    return failureOrSuccess.right
  }
})

Effect.runFork(program)
/*
出力:
timestamp=... level=FATAL fiber=#0 message="Oh uh!"
*/
```

</Tab>
<Tab>

```ts twoslash
import { Effect } from "effect"

const task = Effect.fail("Oh uh!").pipe(Effect.as(2))

const program = task.pipe(
  Effect.catchAll((error) => Effect.logFatal(error).pipe(Effect.as(0)))
)

Effect.runFork(program)
/*
出力:
timestamp=... level=FATAL fiber=#0 message="Oh uh!"
*/
```

</Tab>
</Tabs>

## カスタムアノテーション

`Effect.annotateLogs` 関数を使用してカスタムアノテーションを組み込むことで、ログ出力を強化できます。
この関数を使用すると、エフェクトの各ログエントリに追加のメタデータを付加し、追跡可能性とコンテキストを向上させることができます。

以下は、キー/値のペアとして単一のアノテーションを適用する方法です：

```ts twoslash
import { Effect } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("message1")
  yield* Effect.log("message2")
}).pipe(Effect.annotateLogs("key", "value")) // キー/値ペアとしてのアノテーション

Effect.runFork(program)
/*
出力:
timestamp=... level=INFO fiber=#0 message=message1 key=value
timestamp=... level=INFO fiber=#0 message=message2 key=value
*/
```

複数のアノテーションを一度に適用するには、複数のキー/値ペアを含むオブジェクトを渡すことができます：

```ts twoslash
import { Effect } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("message1")
  yield* Effect.log("message2")
}).pipe(Effect.annotateLogs({ key1: "value1", key2: "value2" }))

Effect.runFork(program)
/*
出力:
timestamp=... level=INFO fiber=#0 message=message1 key2=value2 key1=value1
timestamp=... level=INFO fiber=#0 message=message2 key2=value2 key1=value1
*/
```

アノテーションは、`Effect.annotateLogsScoped`を使用してスコープ付きのライフタイムで適用することもできます。
このメソッドは、エフェクト計算の特定の[Scope](../resource-management/scope)内のログにアノテーションの適用を制限します：

```ts twoslash
import { Effect } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("no annotations")
  yield* Effect.annotateLogsScoped({ key: "value" })
  yield* Effect.log("message1") // このログにアノテーションが適用されます
  yield* Effect.log("message2") // このログにアノテーションが適用されます
}).pipe(Effect.scoped, Effect.andThen(Effect.log("no annotations again")))

Effect.runFork(program)
/*
出力:
timestamp=... level=INFO fiber=#0 message="no annotations"
timestamp=... level=INFO fiber=#0 message=message1 key=value
timestamp=... level=INFO fiber=#0 message=message2 key=value
timestamp=... level=INFO fiber=#0 message="no annotations again"
*/
```

## ログスパン

Effectはまた、ログスパンのサポートも提供しており、プログラム内の特定の操作やタスクの所要時間を測定することができます。

<Tabs items={["Effect.genを使用する", "pipeを使用する"]}>
<Tab>

```ts twoslash
import { Effect } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.sleep("1 second")
  yield* Effect.log("The job is finished!")
}).pipe(Effect.withLogSpan("myspan"))

Effect.runFork(program)
/*
出力:
timestamp=... level=INFO fiber=#0 message="The job is finished!" myspan=1011ms
*/
```

</Tab>
<Tab>

```ts twoslash
import { Effect } from "effect"

const program = Effect.sleep("1 second").pipe(
  Effect.andThen(Effect.log("The job is finished!")),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program)
/*
出力:
timestamp=... level=INFO fiber=#0 message="The job is finished!" myspan=1011ms
*/
```

</Tab>
</Tabs>

上記の例では、`Effect.withLogSpan(label)`関数を使用してログスパンが作成されています。
これはスパン内のコードブロックの実行時間を測定します。
測定された実行時間は、自動的にログメッセージ内のアノテーションとして記録されます。

## デフォルトのロギングを無効にする

テスト実行中などにデフォルトのロギングを無効にする必要がある場合、Effectフレームワーク内でこれを達成するためのさまざまな方法があります。このセクションでは、デフォルトのロギングを無効にするための異なる方法を探ります。

**withMinimumLogLevelを使用する**

Effectは、最小ログレベルを設定してロギングを実質的に無効にする便利な関数`withMinimumLogLevel`を提供しています：

```ts twoslash
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("Executing task...")
  yield* Effect.sleep("100 millis")
  console.log("task done")
})

// ロギングが有効（デフォルト）
Effect.runFork(program)
/*
出力:
timestamp=... level=INFO fiber=#0 message="Executing task..."
task done
*/

// withMinimumLogLevelを使用してロギングを無効化
Effect.runFork(program.pipe(Logger.withMinimumLogLevel(LogLevel.None)))
/*
出力:
task done
*/
```

ログレベルを`LogLevel.None`に設定することで、ロギングを実質的に無効にし、最終結果のみが表示されます。

**レイヤーを使用する**

別の方法として、最小ログレベルを`LogLevel.None`に設定するレイヤーを作成することで、ロギングを実質的に無効にすることができます。

```ts twoslash
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("Executing task...")
  yield* Effect.sleep("100 millis")
  console.log("task done")
})

const layer = Logger.minimumLogLevel(LogLevel.None)

// レイヤーを使用してロギングを無効化
Effect.runFork(program.pipe(Effect.provide(layer)))
/*
出力:
task done
*/
```

**カスタムランタイムの使用**

ロギングを無効にする設定を含むカスタムランタイムを作成することでも、ロギングを無効にすることができます。

```ts twoslash
import { Effect, Logger, LogLevel, ManagedRuntime } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("Executing task...")
  yield* Effect.sleep("100 millis")
  console.log("task done")
})

const customRuntime = ManagedRuntime.make(
  Logger.minimumLogLevel(LogLevel.None)
)

customRuntime.runPromise(program)
/*
出力:
task done
*/
```

このアプローチでは、ロギングを無効にする設定を組み込んだカスタムランタイムを作成し、そのカスタムランタイムを使用してプログラムを実行します。

## 設定からログレベルを読み込む

[設定](../configuration)からログレベルを取得し、それをプログラムに組み込むには、`Logger.minimumLogLevel`によって生成されるレイヤーを利用します。

```ts twoslash
import {
  Effect,
  Config,
  Logger,
  Layer,
  ConfigProvider,
  LogLevel
} from "effect"

// ログを含むプログラムをシミュレートする
const program = Effect.gen(function* () {
  yield* Effect.logError("ERROR!")
  yield* Effect.logWarning("WARNING!")
  yield* Effect.logInfo("INFO!")
  yield* Effect.logDebug("DEBUG!")
})

// 設定からログレベルをレイヤーとして読み込む
const LogLevelLive = Config.logLevel("LOG_LEVEL").pipe(
  Effect.andThen((level) => Logger.minimumLogLevel(level)),
  Layer.unwrapEffect
)

// 読み込んだログレベルでプログラムを設定する
const configured = Effect.provide(program, LogLevelLive)

// ConfigProvider.fromMapを使用して設定されたプログラムをテストする
const test = Effect.provide(
  configured,
  Layer.setConfigProvider(
    ConfigProvider.fromMap(new Map([["LOG_LEVEL", LogLevel.Warning.label]]))
  )
)

Effect.runFork(test)
/*
出力:
... level=ERROR fiber=#0 message=ERROR!
... level=WARN fiber=#0 message=WARNING!
*/
```

設定されたプログラムを評価するには、テスト用に`ConfigProvider.fromMap`を使用できます（詳細は[サービスのテスト](../configuration#testing-services)を参照してください）。

## カスタムロガー

このセクションでは、カスタムロガーを定義し、それをデフォルトのロガーとして設定する方法を学びます。

まず、`Logger.make`を使用してカスタムロガーを定義しましょう：

```twoslash include CustomLogger
import { Logger } from "effect"

export const logger = Logger.make(({ logLevel, message }) => {
  globalThis.console.log(`[${logLevel.label}] ${message}`)
})
```

```ts filename="CustomLogger.ts" twoslash
// @include: CustomLogger
```

次のプログラムが定義されていると仮定します：

<Tabs items={["Effect.genを使用", "pipeを使用"]}>
<Tab>

```twoslash include program
import { Effect } from "effect"

const task1 = Effect.gen(function* () {
  yield* Effect.sleep("2 seconds")
  yield* Effect.logDebug("task1 done")
})

const task2 = Effect.gen(function* () {
  yield* Effect.sleep("1 second")
  yield* Effect.logDebug("task2 done")
})

export const program = Effect.gen(function* () {
  yield* Effect.log("start")
  yield* task1
  yield* task2
  yield* Effect.log("done")
})
```

```ts filename="program.ts" twoslash
// @include: program
```

</Tab>
<Tab>

```ts filename="program.ts" twoslash
import { Effect } from "effect"

const task1 = Effect.sleep("2 seconds").pipe(
  Effect.andThen(Effect.logDebug("task1 done"))
)

const task2 = Effect.sleep("1 second").pipe(
  Effect.andThen(Effect.logDebug("task2 done"))
)

export const program = Effect.log("start").pipe(
  Effect.andThen(task1),
  Effect.andThen(task2),
  Effect.andThen(Effect.log("done"))
)
```

</Tab>
</Tabs>

デフォルトのロガーを置き換えるには、`Logger.replace`を使用して特定のレイヤーを作成し、それを`Effect.provide`を使ってプログラムに提供してから実行するだけです。

```ts filename="index.ts" twoslash
// @filename: CustomLogger.ts
// @include: CustomLogger

// @filename: program.ts
// @include: program

// @filename: index.ts
// ---cut---
import { Effect, Logger, LogLevel } from "effect"
import * as CustomLogger from "./CustomLogger"
import { program } from "./program"

// デフォルトのロガーをカスタムロガーに置き換える
const layer = Logger.replace(Logger.defaultLogger, CustomLogger.logger)

Effect.runFork(
  program.pipe(
    Logger.withMinimumLogLevel(LogLevel.Debug),
    Effect.provide(layer)
  )
)
```

プログラムを実行した後、コンソールに表示される内容は次のとおりです：

```bash filename="Terminal"
[INFO] start
[DEBUG] task1 done
[DEBUG] task2 done
[INFO] done
```

## 組み込みロガー

### json

`json`ロガーは、ログエントリをJSONオブジェクトとしてフォーマットします。これにより、JSONデータを消費するロギングシステムとの統合が容易になります。

```ts twoslash
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.json)))
// {"message":["message1","message2"],"logLevel":"INFO","timestamp":"...","annotations":{"key2":"value2","key1":"value1"},"spans":{"myspan":0},"fiberId":"#0"}
```

### logFmt

このロガーは、開発中や本番環境のコンソールで読みやすい人間可読形式でログを出力します。

```ts twoslash
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))
// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1
```

### structured

構造化ロガーは、イベントの包括的な追跡可能性を保持する方法で構造化された詳細なログ出力を提供します。これは、より深い分析やトラブルシューティングに適しています。

```ts twoslash
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.structured)))
/*
{
  message: [ 'message1', 'message2' ],
  logLevel: 'INFO',
  timestamp: '2024-07-09T14:05:41.623Z',
  cause: undefined,
  annotations: { key2: 'value2', key1: 'value1' },
  spans: { myspan: 0 },
  fiberId: '#0'
}
*/
```

### pretty

`pretty`ロガーは`console` APIの機能を活用して、視覚的に魅力的で色彩豊かなログ出力を生成します。
この機能は、開発やデバッグ過程でログメッセージの読みやすさを向上させるのに特に役立ちます。

```ts twoslash
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))
/*
        green --v                      v-- bold and cyan
[07:51:54.434] INFO (#0) myspan=1ms: message1
  message2
   v-- bold
  key2: value2
  key1: value1
*/
```

ログレベルは以下のように色分けされています：

| ログレベル | 色           |
| ---------- | ------------ |
| Trace      | グレー       |
| Debug      | ブルー       |
| Info       | グリーン     |
| Warning    | イエロー     |
| Error      | レッド       |
| Fatal      | 赤地に白文字 |
