---
title: サービスの管理
excerpt: Effectプログラミングにおけるサービスの概念、アプリケーション全体で特定の機能を提供するために設計された再利用可能なコンポーネントについて理解します。エフェクトを使用してサービスを管理する方法、サービスインターフェースを作成する方法、およびサービス実装を提供する方法を学びます。サービスが利用可能かどうかに応じて柔軟に対応するためのオプションサービスの使用についても探ります。
bottomNavigation: pagination
---

プログラミングの文脈では、**サービス**とはアプリケーションの異なる部分で使用できる再利用可能なコンポーネントや機能を指します。
サービスは特定の機能を提供するように設計されており、複数のモジュールやコンポーネント間で共有することができます。

サービスは、アプリケーションの異なる部分で必要とされる共通のタスクや操作をカプセル化することがよくあります。
これらは複雑な操作を処理したり、外部システムやAPIとやり取りしたり、データを管理したり、その他の専門的なタスクを実行したりすることができます。

サービスは通常、モジュール化されており、アプリケーションの他の部分から分離されています。
これにより、アプリケーションの全体的な機能に影響を与えることなく、簡単に保守、テスト、および交換することができます。

## 概要

サービスとそのアプリケーション開発への統合について深く掘り下げる際、高度な構造に頼らずに関数管理と依存関係処理の基本原則から始めるのが役立ちます。サービスを必要とするすべての関数に手動でサービスを渡さなければならない状況を想像してみてください：

```ts
const processData = (data: Data, databaseService: DatabaseService) => {
  // データベースサービスを使用した操作
}
```

このアプローチは、アプリケーションが成長するにつれて扱いにくく管理不能になります。サービスを複数の関数層を通して渡す必要が出てくるためです。

これを合理化するために、さまざまなサービスをバンドルする環境オブジェクトの使用を検討するかもしれません:

```ts
type Context = {
  databaseService: DatabaseService
  loggingService: LoggingService
}

const processData = (data: Data, context: Context) => {
  // コンテキストから複数のサービスを使用
}
```

しかし、これは新たな複雑さをもたらします：環境が使用される前に、必要なすべてのサービスで正しく設定されていることを確認する必要があります。これは密結合なコードにつながり、関数の合成やテストをより困難にします。

Effectライブラリは、型システムを活用してこれらの依存関係の管理を簡素化します。
サービスや環境オブジェクトを手動で渡す代わりに、Effectでは`Effect<Success, Error, Requirements>`型の`Requirements`パラメータを使用して、関数の型シグネチャで直接サービスの依存関係を宣言できます。

- **依存関係の宣言**：関数が必要とするサービスを直接その型で指定し、依存関係管理の複雑さを型システムに押し込みます。
- **サービスの提供**：`Effect.provideService`を使用して、必要な関数にサービス実装を利用可能にします。開始時にサービスを提供することで、アプリケーションのすべての部分が必要なサービスに一貫してアクセスできるようになり、クリーンで分離されたアーキテクチャを維持します。

この方法は、サービスと依存関係の手動処理を抽象化し、開発者がビジネスロジックに集中できるようにしながら、コンパイラがすべての依存関係が正しく管理されていることを保証します。
このアプローチはコードを簡素化するだけでなく、保守性と拡張性も向上させます。

Effectでのサービスの管理方法を段階的に見ていきましょう。以下の基本を学びます：

1. **サービスの作成**：独自の機能とインターフェースを持つサービスを定義します。
2. **サービスの使用**：アプリケーションの関数内でサービスにアクセスし、利用します。
3. **サービス実装の提供**：宣言された要件を満たすために、実際のサービス実装を提供します。

## エフェクトを使用したサービスの管理

これまで、Effectフレームワークの例では、外部サービスに依存せずに動作するエフェクトを扱ってきました。つまり、`Effect<Success, Error, Requirements>`型シグネチャの`Requirements`パラメータは`never`に設定され、依存関係がないことを示していました。

しかし、実際のアプリケーションでは、特定のサービスに依存して正しく機能するエフェクトが必要になることがよくあります。これらのサービスは`Context`と呼ばれる構造を通じて管理およびアクセスされます。

Contextは、エフェクトが必要とする可能性のあるすべてのサービスのリポジトリまたはコンテナとして機能します。これらのサービスを維持する保管庫のように動作し、アプリケーションのさまざまな部分が必要に応じてアクセスして使用できるようにします。

Contextに格納されているサービスは、`Effect`型の`Requirements`パラメータに直接反映されます。
Context内の各サービスは、一意の「タグ」によって識別されます。これは本質的にサービスの一意の識別子です。エフェクトが特定のサービスを使用する必要がある場合、そのサービスのタグが`Requirements`型パラメータに含まれます。

### サービスの作成

まず、ランダムな数値を生成するサービスを作成してみましょう。

新しいサービスを作成するには、次の2つの要素が必要です：

- 一意の識別子。
- サービスの可能な操作を記述する型。

最初のサービスを定義してみましょう：

- 一意の識別子として文字列`"MyRandomService"`を使用します。
- サービス型には、ランダムな数値を返す単一の操作`next`が含まれます。

```ts twoslash
import { Effect, Context } from "effect"

class Random extends Context.Tag("MyRandomService")<
  Random,
  { readonly next: Effect.Effect<number> }
>() {}
```

エクスポートされた`Random`値は、Effectにおいて**タグ**として知られています。これはサービスの表現として機能し、Effectが実行時にこのサービスを見つけて使用することを可能にします。

サービスは`Context`と呼ばれるコレクションに格納されます。これは、キーがタグで値がサービスである`Map`のように考えることができます：`Context = Map<Tag, Service>`。

<Info>
タグをグローバルにするためには、識別子（この場合は文字列`"MyRandomService"`）を指定する必要があります。これにより、同じ識別子を持つ2つのタグが同じインスタンスを参照することが保証されます。

一意の識別子を使用することは、ライブリロードが発生するシナリオで特に有用です。これにより、リロードをまたいでインスタンスが保持されるのを助け、インスタンスの重複が発生しないようにします（通常は発生しませんが、一部のバンドラーやフレームワークは予測不可能な動作をすることがあります）。

</Info>

**まとめ**

Effectにおいて、サービス、タグ、およびコンテキストを理解することは、要件を管理し、モジュール化されたアプリケーションを構築するために不可欠です。

| **概念**         | **説明**                                                                                           |
| ---------------- | -------------------------------------------------------------------------------------------------- |
| **サービス**     | アプリケーションの異なる部分で使用される、特定の機能を提供する再利用可能なコンポーネント。         |
| **タグ**         | **サービス**を表す一意の識別子。Effectがそれを見つけて使用することを可能にします。                 |
| **コンテキスト** | サービスを格納するコレクション。**タグ**をキーとし**サービス**を値とするマップのように機能します。 |

### サービスの使用

サービスタグが定義されたので、簡単なプログラムを作成してその使用方法を見てみましょう。

<Tabs items={["Effect.genを使用", "pipeを使用"]}>
<Tab>

```ts twoslash
import { Effect, Context } from "effect"

class Random extends Context.Tag("MyRandomService")<
Random,
{ readonly next: Effect.Effect<number> }

> () {}

const program = Effect.gen(function* () {
const random = yield* Random
const randomNumber = yield\* random.next
console.log(`random number: ${randomNumber}`)
})
```

上記のコードでは、`Random`タグをまるで`Effect`そのもののようにyieldできることがわかります。
これにより、サービスの`next`操作にアクセスすることが可能になります。

</Tab>
<Tab>

```ts twoslash
import { Effect, Context, Console } from "effect"

class Random extends Context.Tag("MyRandomService")<
  Random,
  { readonly next: Effect.Effect<number> }
>() {}

const program = Random.pipe(
  Effect.andThen((random) => random.next),
  Effect.andThen((randomNumber) =>
    Console.log(`random number: ${randomNumber}`)
  )
)
```

上記のコードでは、`Random`タグをまるで`Effect`そのもののようにフラットマップできることがわかります。
これにより、`Effect.andThen`コールバック内でサービスの`next`操作にアクセスすることが可能になります。
次に、`Console.log`ユーティリティを使用して生成されたランダムな数値をログに記録します。

</Tab>
</Tabs>

注目すべき点は、`program`変数の型が`Requirements`型パラメータに`Random`を含んでいることです：`Effect<void, never, Random>`。

これは、プログラムを正常に実行するために`Random`サービスが提供される必要があることを示しています。

必要なサービスを提供せずにエフェクトを実行しようとすると、型チェックエラーが発生します：

```ts twoslash
// @errors: 2345
import { Effect, Context } from "effect"

class Random extends Context.Tag("MyRandomService")<
  Random,
  { readonly next: Effect.Effect<number> }
>() {}

const program = Effect.gen(function* () {
  const random = yield* Random
  const randomNumber = yield* random.next
  console.log(`random number: ${randomNumber}`)
})

// ---cut---
Effect.runSync(program)
```

このエラーを解決し、プログラムを正常に実行するためには、`Random`サービスの実際の実装を提供する必要があります。

次のセクションでは、`Random`サービスを実装し、プログラムに提供する方法を探ります。これにより、プログラムを正常に実行できるようになります。

### サービス実装の提供

`Random`サービスの実際の実装を提供するために、`Effect.provideService`関数を利用できます。

```ts twoslash
import { Effect, Context } from "effect"

class Random extends Context.Tag("MyRandomService")<
  Random,
  { readonly next: Effect.Effect<number> }
>() {}

const program = Effect.gen(function* () {
  const random = yield* Random
  const randomNumber = yield* random.next
  console.log(`random number: ${randomNumber}`)
})

// ---cut---
const runnable = Effect.provideService(program, Random, {
  next: Effect.sync(() => Math.random())
})

Effect.runPromise(runnable)
/*
出力:
random number: 0.8241872233134417
*/
```

上記のコードスニペットでは、先に定義した`program`を呼び出し、`Random`サービスの実装を提供しています。
`Effect.provideService`関数を使用して、`Random`タグとその実装（ランダムな数値を生成する`next`操作を持つオブジェクト）を関連付けます。

`runnable`エフェクトの`Requirements`型パラメータが`never`になっていることに注目してください。これは、エフェクトがもはや提供されるべきサービスを必要としないことを示しています。`Random`サービスの実装が整ったことで、追加の要件なしにプログラムを実行できるようになります。

### サービスタイプの抽出

タグからサービスタイプを取得するには、`Context.Tag.Service`ユーティリティタイプを使用します：

```ts twoslash
import { Effect, Context } from "effect"

class Random extends Context.Tag("MyRandomService")<
  Random,
  { readonly next: Effect.Effect<number> }
>() {}

type RandomShape = Context.Tag.Service<Random>
/*
This is equivalent to:
type RandomShape = {
    readonly next: Effect.Effect<number>;
}
*/
```

## 複数のサービスの使用

複数のサービスを使用する必要がある場合、プロセスは必要な各サービスに対して繰り返されるため、サービスを定義する際に学んだことと同様です。`Random`と`Logger`という2つのサービスが必要な例を見てみましょう：

<Tabs items={["Effect.genを使用する", "pipeを使用する"]}>
<Tab>

```ts twoslash
import { Effect, Context } from "effect"

// 'Random'サービスのタグを作成する
class Random extends Context.Tag("MyRandomService")<
  Random,
  {
    readonly next: Effect.Effect<number>
  }
>() {}

// 'Logger'サービスのタグを作成する
class Logger extends Context.Tag("MyLoggerService")<
  Logger,
  {
    readonly log: (message: string) => Effect.Effect<void>
  }
>() {}

const program = Effect.gen(function* () {
  // 'Random'サービスと'Logger'サービスのインスタンスを取得する
  const random = yield* Random
  const logger = yield* Logger

  // 'Random'サービスを使用してランダムな数値を生成する
  const randomNumber = yield* random.next

  // 'Logger'サービスを使用してランダムな数値をログに記録する
  return yield* logger.log(String(randomNumber))
})
```

</Tab>
<Tab>

```ts twoslash
import { Effect, Context } from "effect"

// 'Random'サービスのタグを作成する
class Random extends Context.Tag("MyRandomService")<
  Random,
  {
    readonly next: Effect.Effect<number>
  }
>() {}

// 'Logger'サービスのタグを作成する
class Logger extends Context.Tag("MyLoggerService")<
  Logger,
  {
    readonly log: (message: string) => Effect.Effect<void>
  }
>() {}

const program =
  // 'Random'サービスと'Logger'サービスのインスタンスを取得する
  Effect.all([Random, Logger]).pipe(
    Effect.andThen(([random, logger]) =>
      // 'Random'サービスを使用してランダムな数値を生成する
      random.next.pipe(
        Effect.andThen((randomNumber) =>
          // 'Logger'サービスを使用してランダムな数値をログに記録する
          logger.log(String(randomNumber))
        )
      )
    )
  )
```

</Tab>
</Tabs>

`program`エフェクトには、`Random | Logger`という`Requirements`型パラメータが追加されており、`Random`サービスと`Logger`サービスの両方が提供される必要があることを示しています。

`program`を実行するには、両方のサービスの実装を提供する必要があります。

```ts twoslash
import { Effect, Context } from "effect"

class Random extends Context.Tag("MyRandomService")<
  Random,
  {
    readonly next: Effect.Effect<number>
  }
>() {}

class Logger extends Context.Tag("MyLoggerService")<
  Logger,
  {
    readonly log: (message: string) => Effect.Effect<void>
  }
>() {}

const program = Effect.gen(function* () {
  const random = yield* Random
  const logger = yield* Logger
  const randomNumber = yield* random.next
  return yield* logger.log(String(randomNumber))
})

// ---cut---
// 'Random'と'Logger'のサービス実装を提供する
const runnable1 = program.pipe(
  Effect.provideService(Random, {
    next: Effect.sync(() => Math.random())
  }),
  Effect.provideService(Logger, {
    log: (message) => Effect.sync(() => console.log(message))
  })
)
```

代わりに、`provideService`を複数回呼び出すのではなく、サービスの実装を単一の`Context`にまとめてから、`Effect.provide`関数を使用して全体のコンテキストを提供することができます。

```ts twoslash
import { Effect, Context } from "effect"

class Random extends Context.Tag("MyRandomService")<
  Random,
  {
    readonly next: Effect.Effect<number>
  }
>() {}

class Logger extends Context.Tag("MyLoggerService")<
  Logger,
  {
    readonly log: (message: string) => Effect.Effect<void>
  }
>() {}

const program = Effect.gen(function* () {
  const random = yield* Random
  const logger = yield* Logger
  const randomNumber = yield* random.next
  return yield* logger.log(String(randomNumber))
})

// ---cut---
// サービスの実装を単一の 'Context' にまとめる
const context = Context.empty().pipe(
  Context.add(Random, { next: Effect.sync(() => Math.random()) }),
  Context.add(Logger, {
    log: (message) => Effect.sync(() => console.log(message))
  })
)

// 'program' に全体のコンテキストを提供する
const runnable2 = Effect.provide(program, context)
```

各サービスの必要な実装を提供することで、実行可能なエフェクトが実行時に両方のサービスにアクセスして利用できるようにします。

## オプションサービス

サービスの実装を利用可能な場合にのみアクセスしたい状況があります。
そのような場合には、`Effect.serviceOption`関数を使用してこのシナリオを処理できます。

`Effect.serviceOption`関数は、このエフェクトを実行する前に実際に提供された場合にのみ利用可能な実装を返します。
この任意性を表現するために、実装の[Option](../../other/data-types/option)を返します。

オプションサービスの使用例を見てみましょう：

<Tabs items={["Effect.genを使用", "pipeを使用"]}>
<Tab>

どのアクションを取るかを決定するために、Optionモジュールが提供する`Option.isNone`関数を使用できます。この関数は、サービスが利用可能かどうかをチェックし、サービスが利用できない場合に`true`を返します。

```ts twoslash
import { Effect, Context, Option } from "effect"

class Random extends Context.Tag("MyRandomService")<
  Random,
  { readonly next: Effect.Effect<number> }
>() {}

const program = Effect.gen(function* () {
  const maybeRandom = yield* Effect.serviceOption(Random)
  const randomNumber = Option.isNone(maybeRandom)
    ? // サービスが利用できない場合、デフォルト値を返す
      -1
    : // サービスが利用可能な場合
      yield* maybeRandom.value.next
  console.log(randomNumber)
})
```

</Tab>
<Tab>

サービスを利用できるかどうかを判断するために、`Option`モジュールが提供する`Option.match`関数を使用できます。この関数は、サービスが利用可能かどうかに基づいて異なるアクションを実行することができます。引数として2つのコールバックを取ります。1つはサービスが利用できない場合のコールバック、もう1つはサービスが利用できる場合のコールバックです。

```ts twoslash
import { Effect, Context, Option, Console } from "effect"

class Random extends Context.Tag("MyRandomService")<
  Random,
  { readonly next: Effect.Effect<number> }
>() {}

const program = Effect.serviceOption(Random).pipe(
  Effect.andThen((maybeRandom) =>
    Option.match(maybeRandom, {
      // サービスが利用できない場合、デフォルト値を返す
      onNone: () => Effect.succeed(-1),
      // サービスが利用可能な場合
      onSome: (random) => random.next
    })
  ),
  Effect.andThen((randomNumber) => Console.log(`${randomNumber}`))
)
```

</Tab>
</Tabs>

上記のコードでは、サービスを使用しているにもかかわらず、`program`エフェクトの`Requirements`型パラメータが`never`であることがわかります。これにより、このエフェクトを実行する前に実際に提供されている場合にのみ、コンテキストから何かにアクセスすることができます。

`Random`サービスを提供せずに`program`エフェクトを実行すると:

```ts
Effect.runPromise(program).then(console.log)
// 出力: -1
```

ログメッセージには、サービスが利用できない場合に提供したデフォルト値である `-1` が含まれていることがわかります。

しかし、`Random` サービスの実装を提供すると：

```ts
Effect.runPromise(
  Effect.provideService(program, Random, {
    next: Effect.sync(() => Math.random())
  })
).then(console.log)
// 出力: 0.9957979486841035
```

ログメッセージに、`Random`サービスの`next`操作によって生成されたランダムな数値が含まれていることが確認できます。
